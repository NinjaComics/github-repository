# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_howto_swig', [dirname(__file__)])
        except ImportError:
            import _howto_swig
            return _howto_swig
        if fp is not None:
            try:
                _mod = imp.load_module('_howto_swig', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _howto_swig = swig_import_helper()
    del swig_import_helper
else:
    import _howto_swig
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def high_res_timer_now():
  """high_res_timer_now() -> gr::high_res_timer_type"""
  return _howto_swig.high_res_timer_now()

def high_res_timer_now_perfmon():
  """high_res_timer_now_perfmon() -> gr::high_res_timer_type"""
  return _howto_swig.high_res_timer_now_perfmon()

def high_res_timer_tps():
  """high_res_timer_tps() -> gr::high_res_timer_type"""
  return _howto_swig.high_res_timer_tps()

def high_res_timer_epoch():
  """high_res_timer_epoch() -> gr::high_res_timer_type"""
  return _howto_swig.high_res_timer_epoch()
class constellation(object):
    """
    An abstracted constellation object.

    The constellation objects hold the necessary information to pass around constellation information for modulators and demodulators. These objects contain the mapping between the bits and the constellation points used to represent them as well as methods for slicing the symbol space. Various implementations are possible for efficiency and ease of use.

    Standard constellations (BPSK, QPSK, QAM, etc) can be inherited from this class and overloaded to perform optimized slicing and constellation mappings.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _howto_swig.delete_constellation
    __del__ = lambda self : None;
    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _howto_swig.constellation_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(constellation self, unsigned int value) -> pmt_vector_cfloat

        Params: (value)
        """
        return _howto_swig.constellation_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _howto_swig.constellation_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _howto_swig.constellation_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _howto_swig.constellation_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation self, gr_complex const * sample, float * metric, gr::howto::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _howto_swig.constellation_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """
        calc_euclidean_metric(constellation self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """
        calc_hard_symbol_metric(constellation self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _howto_swig.constellation_points(self)

    def s_points(self):
        """
        s_points(constellation self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _howto_swig.constellation_s_points(self)

    def v_points(self):
        """
        v_points(constellation self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _howto_swig.constellation_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _howto_swig.constellation_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _howto_swig.constellation_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _howto_swig.constellation_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _howto_swig.constellation_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _howto_swig.constellation_dimensionality(self)

    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_bits_per_symbol(self)

    def arity(self):
        """
        arity(constellation self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_arity(self)

    def base(self):
        """
        base(constellation self) -> constellation_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_base(self)

    def as_pmt(self):
        """
        as_pmt(constellation self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.constellation_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _howto_swig.constellation_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _howto_swig.constellation_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _howto_swig.constellation_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _howto_swig.constellation_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _howto_swig.constellation_soft_decision_maker(self, *args, **kwargs)

constellation_swigregister = _howto_swig.constellation_swigregister
constellation_swigregister(constellation)

class constellation_calcdist(constellation):
    """
    Calculate Euclidian distance for any constellation.

    Constellation which calculates the distance to each point in the constellation for decision making. Inefficient for large constellations.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int dimensionality) -> constellation_calcdist_sptr

        Make a general constellation object that calculates the Euclidean distance for hard decisions.

        Params: (constell, pre_diff_code, rotational_symmetry, dimensionality)
        """
        return _howto_swig.constellation_calcdist_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_constellation_calcdist
    __del__ = lambda self : None;
constellation_calcdist_swigregister = _howto_swig.constellation_calcdist_swigregister
constellation_calcdist_swigregister(constellation_calcdist)

def constellation_calcdist_make(*args, **kwargs):
  """
    constellation_calcdist_make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
        unsigned int rotational_symmetry, unsigned int dimensionality) -> constellation_calcdist_sptr

    Make a general constellation object that calculates the Euclidean distance for hard decisions.

    Params: (constell, pre_diff_code, rotational_symmetry, dimensionality)
    """
  return _howto_swig.constellation_calcdist_make(*args, **kwargs)

class constellation_sector(constellation):
    """
    Sectorized HOWTO constellation.

    constellation_sector

    Constellation space is divided into sectors. Each sector is associated with the nearest constellation point.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _howto_swig.delete_constellation_sector
    __del__ = lambda self : None;
constellation_sector_swigregister = _howto_swig.constellation_sector_swigregister
constellation_sector_swigregister(constellation_sector)

class constellation_rect(constellation_sector):
    """
    Rectangular HOWTO constellation

    Only implemented for 1-(complex)dimensional constellation.

    Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

    Works well for square QAM.

    Works for any generic constellation provided sectors are not too large.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
            float width_real_sectors, float width_imag_sectors) -> constellation_rect_sptr

        Make a rectangular constellation object.

        Params: (constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors)
        """
        return _howto_swig.constellation_rect_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_constellation_rect
    __del__ = lambda self : None;
constellation_rect_swigregister = _howto_swig.constellation_rect_swigregister
constellation_rect_swigregister(constellation_rect)

def constellation_rect_make(*args, **kwargs):
  """
    constellation_rect_make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
        unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
        float width_real_sectors, float width_imag_sectors) -> constellation_rect_sptr

    Make a rectangular constellation object.

    Params: (constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors)
    """
  return _howto_swig.constellation_rect_make(*args, **kwargs)

class constellation_expl_rect(constellation_rect):
    """
    Rectangular HOWTO constellation.

    Only implemented for 1-(complex)dimensional constellation.

    Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

    This class is different from constellation_rect in that the mapping from sector to constellation point is explicitly passed into the constructor as sector_values. Usually we do not need this, since we want each sector to be automatically mapped to the closest constellation point, however sometimes it's nice to have the flexibility.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat constellation, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
            float width_real_sectors, float width_imag_sectors, std::vector< unsigned int,std::allocator< unsigned int > > sector_values) -> constellation_expl_rect_sptr

        Params: (constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values)
        """
        return _howto_swig.constellation_expl_rect_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_constellation_expl_rect
    __del__ = lambda self : None;
constellation_expl_rect_swigregister = _howto_swig.constellation_expl_rect_swigregister
constellation_expl_rect_swigregister(constellation_expl_rect)

def constellation_expl_rect_make(*args, **kwargs):
  """
    constellation_expl_rect_make(pmt_vector_cfloat constellation, std::vector< int,std::allocator< int > > pre_diff_code, 
        unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
        float width_real_sectors, float width_imag_sectors, std::vector< unsigned int,std::allocator< unsigned int > > sector_values) -> constellation_expl_rect_sptr

    Params: (constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values)
    """
  return _howto_swig.constellation_expl_rect_make(*args, **kwargs)

class constellation_psk(constellation_sector):
    """
    constellation_psk

    Constellation space is divided into pie slices sectors.

    Each slice is associated with the nearest constellation point.

    Works well for PSK but nothing else.

    Assumes that there is a constellation point at 1.x
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int n_sectors) -> constellation_psk_sptr

        Params: (constell, pre_diff_code, n_sectors)
        """
        return _howto_swig.constellation_psk_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_constellation_psk
    __del__ = lambda self : None;
constellation_psk_swigregister = _howto_swig.constellation_psk_swigregister
constellation_psk_swigregister(constellation_psk)

def constellation_psk_make(*args, **kwargs):
  """
    constellation_psk_make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
        unsigned int n_sectors) -> constellation_psk_sptr

    Params: (constell, pre_diff_code, n_sectors)
    """
  return _howto_swig.constellation_psk_make(*args, **kwargs)

class constellation_bpsk(constellation):
    """HOWTO constellation for BPSK ."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> constellation_bpsk_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_make()

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_constellation_bpsk
    __del__ = lambda self : None;
constellation_bpsk_swigregister = _howto_swig.constellation_bpsk_swigregister
constellation_bpsk_swigregister(constellation_bpsk)

def constellation_bpsk_make():
  """
    constellation_bpsk_make() -> constellation_bpsk_sptr

    Params: (NONE)
    """
  return _howto_swig.constellation_bpsk_make()

class constellation_qpsk(constellation):
    """HOWTO constellation for QPSK."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> constellation_qpsk_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_make()

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_constellation_qpsk
    __del__ = lambda self : None;
constellation_qpsk_swigregister = _howto_swig.constellation_qpsk_swigregister
constellation_qpsk_swigregister(constellation_qpsk)

def constellation_qpsk_make():
  """
    constellation_qpsk_make() -> constellation_qpsk_sptr

    Params: (NONE)
    """
  return _howto_swig.constellation_qpsk_make()

class constellation_dqpsk(constellation):
    """HOWTO constellation for DQPSK."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> constellation_dqpsk_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_make()

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_constellation_dqpsk
    __del__ = lambda self : None;
constellation_dqpsk_swigregister = _howto_swig.constellation_dqpsk_swigregister
constellation_dqpsk_swigregister(constellation_dqpsk)

def constellation_dqpsk_make():
  """
    constellation_dqpsk_make() -> constellation_dqpsk_sptr

    Params: (NONE)
    """
  return _howto_swig.constellation_dqpsk_make()

class constellation_8psk(constellation):
    """HOWTO constellation for 8PSK."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> constellation_8psk_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_make()

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_constellation_8psk
    __del__ = lambda self : None;
constellation_8psk_swigregister = _howto_swig.constellation_8psk_swigregister
constellation_8psk_swigregister(constellation_8psk)

def constellation_8psk_make():
  """
    constellation_8psk_make() -> constellation_8psk_sptr

    Params: (NONE)
    """
  return _howto_swig.constellation_8psk_make()

class ofdm_equalizer_base(object):
    """Proxy of C++ gr::howto::ofdm_equalizer_base class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _howto_swig.delete_ofdm_equalizer_base
    __del__ = lambda self : None;
    def reset(self):
        """
        reset(ofdm_equalizer_base self)

        Reset the channel information state knowledge.

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_base_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_base self, gr_complex * frame, int n_sym, int const n_symbol, int start_pos, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.

        Params: (frame, n_sym, n_symbol, start_pos, initial_taps, tags)
        """
        return _howto_swig.ofdm_equalizer_base_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(ofdm_equalizer_base self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _howto_swig.ofdm_equalizer_base_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """
        fft_len(ofdm_equalizer_base self) -> int

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_base_fft_len(self)

    def base(self):
        """
        base(ofdm_equalizer_base self) -> ofdm_equalizer_base_sptr

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_base_base(self)

ofdm_equalizer_base_swigregister = _howto_swig.ofdm_equalizer_base_swigregister
ofdm_equalizer_base_swigregister(ofdm_equalizer_base)

class ofdm_equalizer_1d_pilots(ofdm_equalizer_base):
    """Proxy of C++ gr::howto::ofdm_equalizer_1d_pilots class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _howto_swig.delete_ofdm_equalizer_1d_pilots
    __del__ = lambda self : None;
ofdm_equalizer_1d_pilots_swigregister = _howto_swig.ofdm_equalizer_1d_pilots_swigregister
ofdm_equalizer_1d_pilots_swigregister(ofdm_equalizer_1d_pilots)

class ofdm_equalizer_simpledfe(ofdm_equalizer_1d_pilots):
    """Proxy of C++ gr::howto::ofdm_equalizer_simpledfe class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::howto::ofdm_equalizer_simpledfe self, int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            float alpha=0.1, 
            bool input_is_shifted=True) -> ofdm_equalizer_simpledfe

        Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
        """
        this = _howto_swig.new_ofdm_equalizer_simpledfe(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _howto_swig.delete_ofdm_equalizer_simpledfe
    __del__ = lambda self : None;
    def make(*args, **kwargs):
        """
        make(int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            float alpha=0.1, 
            bool input_is_shifted=True) -> ofdm_equalizer_simpledfe_sptr

        Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
        """
        return _howto_swig.ofdm_equalizer_simpledfe_make(*args, **kwargs)

    make = staticmethod(make)
ofdm_equalizer_simpledfe_swigregister = _howto_swig.ofdm_equalizer_simpledfe_swigregister
ofdm_equalizer_simpledfe_swigregister(ofdm_equalizer_simpledfe)

def ofdm_equalizer_simpledfe_make(*args, **kwargs):
  """
    ofdm_equalizer_simpledfe_make(int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
        std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
        gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
        int symbols_skipped=0, 
        float alpha=0.1, 
        bool input_is_shifted=True) -> ofdm_equalizer_simpledfe_sptr

    Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
    """
  return _howto_swig.ofdm_equalizer_simpledfe_make(*args, **kwargs)

class sc_fdma_equalizer_base(object):
    """Proxy of C++ gr::howto::sc_fdma_equalizer_base class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _howto_swig.delete_sc_fdma_equalizer_base
    __del__ = lambda self : None;
    def reset(self):
        """
        reset(sc_fdma_equalizer_base self)

        Reset the channel information state knowledge.

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_base_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(sc_fdma_equalizer_base self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.

        Params: (frame, n_sym, initial_taps, tags)
        """
        return _howto_swig.sc_fdma_equalizer_base_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(sc_fdma_equalizer_base self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _howto_swig.sc_fdma_equalizer_base_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """
        fft_len(sc_fdma_equalizer_base self) -> int

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_base_fft_len(self)

    def base(self):
        """
        base(sc_fdma_equalizer_base self) -> sc_fdma_equalizer_base_sptr

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_base_base(self)

sc_fdma_equalizer_base_swigregister = _howto_swig.sc_fdma_equalizer_base_swigregister
sc_fdma_equalizer_base_swigregister(sc_fdma_equalizer_base)

class sc_fdma_equalizer_1d_pilots(sc_fdma_equalizer_base):
    """Proxy of C++ gr::howto::sc_fdma_equalizer_1d_pilots class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _howto_swig.delete_sc_fdma_equalizer_1d_pilots
    __del__ = lambda self : None;
sc_fdma_equalizer_1d_pilots_swigregister = _howto_swig.sc_fdma_equalizer_1d_pilots_swigregister
sc_fdma_equalizer_1d_pilots_swigregister(sc_fdma_equalizer_1d_pilots)

class sc_fdma_equalizer_simpledfe(sc_fdma_equalizer_1d_pilots):
    """Proxy of C++ gr::howto::sc_fdma_equalizer_simpledfe class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::howto::sc_fdma_equalizer_simpledfe self, int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            float alpha=0.1, 
            bool input_is_shifted=True) -> sc_fdma_equalizer_simpledfe

        Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
        """
        this = _howto_swig.new_sc_fdma_equalizer_simpledfe(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _howto_swig.delete_sc_fdma_equalizer_simpledfe
    __del__ = lambda self : None;
    def make(*args, **kwargs):
        """
        make(int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            float alpha=0.1, 
            bool input_is_shifted=True) -> sc_fdma_equalizer_simpledfe_sptr

        Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
        """
        return _howto_swig.sc_fdma_equalizer_simpledfe_make(*args, **kwargs)

    make = staticmethod(make)
sc_fdma_equalizer_simpledfe_swigregister = _howto_swig.sc_fdma_equalizer_simpledfe_swigregister
sc_fdma_equalizer_simpledfe_swigregister(sc_fdma_equalizer_simpledfe)

def sc_fdma_equalizer_simpledfe_make(*args, **kwargs):
  """
    sc_fdma_equalizer_simpledfe_make(int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
        std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
        gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
        int symbols_skipped=0, 
        float alpha=0.1, 
        bool input_is_shifted=True) -> sc_fdma_equalizer_simpledfe_sptr

    Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
    """
  return _howto_swig.sc_fdma_equalizer_simpledfe_make(*args, **kwargs)

class packet_header_default(object):
    """
    Default header formatter for howto packet transmission.

    For bursty/packetized howto transmission, packets are usually prepended with a packet header, containing the number of bytes etc. This class is not a block, but a tool to create these packet header.

    This is a default packet header (see header_formatter()) for a description on the header format). To create other header, derive packet header creator classes from this function.

    gr::howto::packet_headergenerator_bb uses header generators derived from this class to create packet headers from data streams.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::howto::packet_header_default self, long header_len, std::string const & len_tag_key="packet_len", std::string const & num_tag_key="packet_num", 
            std::string const & device_id_tag_key="device_id", 
            std::string const & message_type_tag_key="message_type", int bits_per_byte=1) -> packet_header_default

        Params: (header_len, len_tag_key, num_tag_key, device_id_tag_key, message_type_tag_key, bits_per_byte)
        """
        this = _howto_swig.new_packet_header_default(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _howto_swig.delete_packet_header_default
    __del__ = lambda self : None;
    def base(self):
        """
        base(packet_header_default self) -> packet_header_default_sptr

        Params: (NONE)
        """
        return _howto_swig.packet_header_default_base(self)

    def formatter(self):
        """
        formatter(packet_header_default self) -> packet_header_default_sptr

        Params: (NONE)
        """
        return _howto_swig.packet_header_default_formatter(self)

    def set_header_num(self, *args, **kwargs):
        """
        set_header_num(packet_header_default self, unsigned int header_num)

        Params: (header_num)
        """
        return _howto_swig.packet_header_default_set_header_num(self, *args, **kwargs)

    def header_len(self):
        """
        header_len(packet_header_default self) -> long

        Params: (NONE)
        """
        return _howto_swig.packet_header_default_header_len(self)

    def len_tag_key(self):
        """
        len_tag_key(packet_header_default self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.packet_header_default_len_tag_key(self)

    def header_formatter(self, *args, **kwargs):
        """
        header_formatter(packet_header_default self, long packet_len, unsigned char * out, tags_vector_t tags=std::vector< gr::tag_t >()) -> bool

        Encodes the header information in the given tags into bits and places them into .

        Uses the following header format: Bits 0-11: The packet length (what was stored in the tag with key ) Bits 12-23: The header number (counts up everytime this function is called) Bit 24-31: 8-Bit CRC All other bits: Are set to zero

        If the header length is smaller than 32, bits are simply left out. For this reason, they always start with the LSB.

        However, it is recommended to stay above 32 Bits, in order to have a working CRC.

        Params: (packet_len, out, tags)
        """
        return _howto_swig.packet_header_default_header_formatter(self, *args, **kwargs)

    def header_parser(self, *args, **kwargs):
        """
        header_parser(packet_header_default self, unsigned char const * header, tags_vector_t tags) -> bool

        Inverse function to header_formatter().

        Reads the bit stream in  and writes a corresponding tag into .

        Params: (header, tags)
        """
        return _howto_swig.packet_header_default_header_parser(self, *args, **kwargs)

    def make(*args, **kwargs):
        """
        make(long header_len, std::string const & len_tag_key="packet_len", std::string const & num_tag_key="packet_num", 
            std::string const & device_id_tag_key="device_id", 
            std::string const & message_type_tag_key="message_type", int bits_per_byte=1) -> packet_header_default_sptr

        Params: (header_len, len_tag_key, num_tag_key, device_id_tag_key, message_type_tag_key, bits_per_byte)
        """
        return _howto_swig.packet_header_default_make(*args, **kwargs)

    make = staticmethod(make)
packet_header_default_swigregister = _howto_swig.packet_header_default_swigregister
packet_header_default_swigregister(packet_header_default)

def packet_header_default_make(*args, **kwargs):
  """
    packet_header_default_make(long header_len, std::string const & len_tag_key="packet_len", std::string const & num_tag_key="packet_num", 
        std::string const & device_id_tag_key="device_id", 
        std::string const & message_type_tag_key="message_type", int bits_per_byte=1) -> packet_header_default_sptr

    Params: (header_len, len_tag_key, num_tag_key, device_id_tag_key, message_type_tag_key, bits_per_byte)
    """
  return _howto_swig.packet_header_default_make(*args, **kwargs)

class packet_header_ofdm(packet_header_default):
    """Proxy of C++ gr::howto::packet_header_ofdm class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::howto::packet_header_ofdm self, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            int n_syms, std::string const & len_tag_key, 
            std::string const & frame_len_tag_key, std::string const & num_tag_key, 
            std::string const & device_id_tag_key, std::string const & message_type_tag_key, 
            int bits_per_header_sym, int bits_per_payload_sym, 
            bool header_split, bool scramble_header) -> packet_header_ofdm

        Params: (occupied_carriers, n_syms, len_tag_key, frame_len_tag_key, num_tag_key, device_id_tag_key, message_type_tag_key, bits_per_header_sym, bits_per_payload_sym, header_split, scramble_header)
        """
        this = _howto_swig.new_packet_header_ofdm(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _howto_swig.delete_packet_header_ofdm
    __del__ = lambda self : None;
    def make(*args, **kwargs):
        """
        make(std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            int n_syms, std::string const & len_tag_key="packet_len", 
            std::string const & frame_len_tag_key="frame_len", 
            std::string const & num_tag_key="packet_num", std::string const & device_id_tag_key="device_id", 
            std::string const & message_type_tag_key="message_type", 
            int bits_per_header_sym=1, int bits_per_payload_sym=1, 
            bool header_split=False, bool scramble_header=False) -> packet_header_ofdm_sptr

        Params: (occupied_carriers, n_syms, len_tag_key, frame_len_tag_key, num_tag_key, device_id_tag_key, message_type_tag_key, bits_per_header_sym, bits_per_payload_sym, header_split, scramble_header)
        """
        return _howto_swig.packet_header_ofdm_make(*args, **kwargs)

    make = staticmethod(make)
packet_header_ofdm_swigregister = _howto_swig.packet_header_ofdm_swigregister
packet_header_ofdm_swigregister(packet_header_ofdm)

def packet_header_ofdm_make(*args, **kwargs):
  """
    packet_header_ofdm_make(std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
        int n_syms, std::string const & len_tag_key="packet_len", 
        std::string const & frame_len_tag_key="frame_len", 
        std::string const & num_tag_key="packet_num", std::string const & device_id_tag_key="device_id", 
        std::string const & message_type_tag_key="message_type", 
        int bits_per_header_sym=1, int bits_per_payload_sym=1, 
        bool header_split=False, bool scramble_header=False) -> packet_header_ofdm_sptr

    Params: (occupied_carriers, n_syms, len_tag_key, frame_len_tag_key, num_tag_key, device_id_tag_key, message_type_tag_key, bits_per_header_sym, bits_per_payload_sym, header_split, scramble_header)
    """
  return _howto_swig.packet_header_ofdm_make(*args, **kwargs)

class ofdm_carrier_allocator_cvc(object):
    """
    Create frequency domain OFDM symbols from complex values, add pilots.

    This block turns a stream of complex, scalar modulation symbols into vectors which are the input for an IFFT in an OFDM transmitter. It also supports the possibility of placing pilot symbols onto the carriers.

    The carriers can be allocated freely, if a carrier is not allocated, it is set to zero. This allows doing OFDMA-style carrier allocations.

    Input: A tagged stream of complex scalars. The first item must have a tag containing the number of complex symbols in this frame. Output: A tagged stream of complex vectors of length fft_len. This can directly be connected to an FFT block. Make sure to set this block to 'reverse' for the IFFT. If  is true, the FFT block must activate FFT shifting, otherwise, set shifting to false. If given, sync words are prepended to the output. Note that sync words are prepended verbatim, make sure they are shifted (or not).

    Carrier indexes are always such that index 0 is the DC carrier (note: you should not allocate this carrier). The carriers below the DC carrier are either indexed with negative numbers, or with indexes larger than . Index -1 and index  both identify the carrier below the DC carrier.

    Tags are propagated such that a tag on an incoming complex symbol is mapped to the corresponding OFDM symbol. There is one exception: If a tag is on the first OFDM symbol, it is assumed that this tag should stay there, so it is moved to the front even if a sync word is included (any other tags will never be attached to the sync word). This allows tags to control the transmit timing to pass through in the correct position.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def len_tag_key(self):
        """
        len_tag_key(ofdm_carrier_allocator_cvc self) -> std::string

        Params: (NONE)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_len_tag_key(self)

    def fft_len(self):
        """
        fft_len(ofdm_carrier_allocator_cvc self) -> int const

        Params: (NONE)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_fft_len(self)

    def occupied_carriers(self):
        """
        occupied_carriers(ofdm_carrier_allocator_cvc self) -> std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >

        Params: (NONE)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_occupied_carriers(self)

    def pilot_carriers(self):
        """
        pilot_carriers(ofdm_carrier_allocator_cvc self) -> std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >

        Params: (NONE)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_pilot_carriers(self)

    def make(*args, **kwargs):
        """
        make(int num_user, float total_power, int bandwidth, float noise_density, int fft_len, 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, 
            gr_vector_vector_complexf pilot_symbols, 
            gr_vector_vector_complexf sync_words, 
            std::string const & len_tag_key="packet_len", 
            bool const output_is_shifted=True) -> ofdm_carrier_allocator_cvc_sptr

        Params: (num_user, total_power, bandwidth, noise_density, fft_len, occupied_carriers, pilot_carriers, pilot_symbols, sync_words, len_tag_key, output_is_shifted)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_ofdm_carrier_allocator_cvc
    __del__ = lambda self : None;
ofdm_carrier_allocator_cvc_swigregister = _howto_swig.ofdm_carrier_allocator_cvc_swigregister
ofdm_carrier_allocator_cvc_swigregister(ofdm_carrier_allocator_cvc)

def ofdm_carrier_allocator_cvc_make(*args, **kwargs):
  """
    ofdm_carrier_allocator_cvc_make(int num_user, float total_power, int bandwidth, float noise_density, int fft_len, 
        std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
        std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, 
        gr_vector_vector_complexf pilot_symbols, 
        gr_vector_vector_complexf sync_words, 
        std::string const & len_tag_key="packet_len", 
        bool const output_is_shifted=True) -> ofdm_carrier_allocator_cvc_sptr

    Params: (num_user, total_power, bandwidth, noise_density, fft_len, occupied_carriers, pilot_carriers, pilot_symbols, sync_words, len_tag_key, output_is_shifted)
    """
  return _howto_swig.ofdm_carrier_allocator_cvc_make(*args, **kwargs)

class ofdm_carrier_allocator_cvc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::ofdm_carrier_allocator_cvc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::ofdm_carrier_allocator_cvc)> self) -> ofdm_carrier_allocator_cvc_sptr
        __init__(boost::shared_ptr<(gr::howto::ofdm_carrier_allocator_cvc)> self, ofdm_carrier_allocator_cvc p) -> ofdm_carrier_allocator_cvc_sptr
        """
        this = _howto_swig.new_ofdm_carrier_allocator_cvc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_carrier_allocator_cvc_sptr self) -> ofdm_carrier_allocator_cvc"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_ofdm_carrier_allocator_cvc_sptr
    __del__ = lambda self : None;
    def len_tag_key(self):
        """
        len_tag_key(ofdm_carrier_allocator_cvc_sptr self) -> std::string

        Params: (NONE)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_len_tag_key(self)

    def fft_len(self):
        """
        fft_len(ofdm_carrier_allocator_cvc_sptr self) -> int const

        Params: (NONE)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_fft_len(self)

    def occupied_carriers(self):
        """
        occupied_carriers(ofdm_carrier_allocator_cvc_sptr self) -> std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >

        Params: (NONE)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_occupied_carriers(self)

    def pilot_carriers(self):
        """
        pilot_carriers(ofdm_carrier_allocator_cvc_sptr self) -> std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >

        Params: (NONE)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pilot_carriers(self)

    def make(self, *args, **kwargs):
        """
        make(ofdm_carrier_allocator_cvc_sptr self, int num_user, float total_power, int bandwidth, float noise_density, int fft_len, 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, 
            gr_vector_vector_complexf pilot_symbols, 
            gr_vector_vector_complexf sync_words, 
            std::string const & len_tag_key="packet_len", 
            bool const output_is_shifted=True) -> ofdm_carrier_allocator_cvc_sptr

        Params: (num_user, total_power, bandwidth, noise_density, fft_len, occupied_carriers, pilot_carriers, pilot_symbols, sync_words, len_tag_key, output_is_shifted)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_carrier_allocator_cvc_sptr self) -> unsigned int"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_carrier_allocator_cvc_sptr self, int which, int delay)
        declare_sample_delay(ofdm_carrier_allocator_cvc_sptr self, unsigned int delay)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_carrier_allocator_cvc_sptr self, int which) -> unsigned int"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_carrier_allocator_cvc_sptr self) -> int"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_carrier_allocator_cvc_sptr self) -> double"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_carrier_allocator_cvc_sptr self) -> bool"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_start(self)

    def stop(self):
        """stop(ofdm_carrier_allocator_cvc_sptr self) -> bool"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_carrier_allocator_cvc_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_carrier_allocator_cvc_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_carrier_allocator_cvc_sptr self) -> int"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_carrier_allocator_cvc_sptr self, int m)"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_carrier_allocator_cvc_sptr self)"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_carrier_allocator_cvc_sptr self) -> bool"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_carrier_allocator_cvc_sptr self, int m)"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_carrier_allocator_cvc_sptr self) -> int"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_carrier_allocator_cvc_sptr self, int i) -> long"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_carrier_allocator_cvc_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_carrier_allocator_cvc_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_carrier_allocator_cvc_sptr self, int i) -> long"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_carrier_allocator_cvc_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_carrier_allocator_cvc_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_carrier_allocator_cvc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_carrier_allocator_cvc_sptr self)"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_carrier_allocator_cvc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_carrier_allocator_cvc_sptr self) -> int"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_carrier_allocator_cvc_sptr self) -> int"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_carrier_allocator_cvc_sptr self, int priority) -> int"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_carrier_allocator_cvc_sptr self) -> std::string"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_carrier_allocator_cvc_sptr self) -> std::string"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_carrier_allocator_cvc_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_carrier_allocator_cvc_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_carrier_allocator_cvc_sptr self) -> long"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_carrier_allocator_cvc_sptr self) -> basic_block_sptr"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_carrier_allocator_cvc_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_carrier_allocator_cvc_sptr self) -> std::string"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_carrier_allocator_cvc_sptr self, std::string name)"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_carrier_allocator_cvc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_carrier_allocator_cvc_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_carrier_allocator_cvc_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_carrier_allocator_cvc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.ofdm_carrier_allocator_cvc_sptr_message_subscribers(self, *args, **kwargs)

ofdm_carrier_allocator_cvc_sptr_swigregister = _howto_swig.ofdm_carrier_allocator_cvc_sptr_swigregister
ofdm_carrier_allocator_cvc_sptr_swigregister(ofdm_carrier_allocator_cvc_sptr)

ofdm_carrier_allocator_cvc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_carrier_allocator_cvc = ofdm_carrier_allocator_cvc.make;

class ofdm_chanest_vcvc(object):
    """
    Estimate channel and coarse frequency offset for OFDM from preambles

    Input: OFDM symbols (in frequency domain). The first one (or two) symbols are expected to be synchronisation symbols, which are used to estimate the coarse freq offset and the initial equalizer taps (these symbols are removed from the stream). The following  are passed through unmodified (the actual equalisation must be done elsewhere). Output: The data symbols, without the synchronisation symbols. The first data symbol passed through has two tags: 'ofdm_sync_carr_offset' (integer), the coarse frequency offset as number of carriers, and 'ofdm_sync_eq_taps' (complex vector). Any tags attached to the synchronisation symbols are attached to the first data symbol. All other tags are propagated as expected.

    Note: The vector on ofdm_sync_eq_taps is already frequency-corrected, whereas the rest is not.

    This block assumes the frequency offset is even (i.e. an integer multiple of 2).

    [1] Schmidl, T.M. and Cox, D.C., "Robust frequency and timing synchronization for OFDM", Communications, IEEE Transactions on, 1997. [2] K.D. Kammeyer, "Nachrichtenuebertragung," Chapter. 16.3.2.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat sync_symbol1, pmt_vector_cfloat sync_symbol2, int n_data_symbols, 
            int eq_noise_red_len=0, int max_carr_offset=-1, bool force_one_sync_symbol=False) -> ofdm_chanest_vcvc_sptr

        Params: (sync_symbol1, sync_symbol2, n_data_symbols, eq_noise_red_len, max_carr_offset, force_one_sync_symbol)
        """
        return _howto_swig.ofdm_chanest_vcvc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_ofdm_chanest_vcvc
    __del__ = lambda self : None;
ofdm_chanest_vcvc_swigregister = _howto_swig.ofdm_chanest_vcvc_swigregister
ofdm_chanest_vcvc_swigregister(ofdm_chanest_vcvc)

def ofdm_chanest_vcvc_make(*args, **kwargs):
  """
    ofdm_chanest_vcvc_make(pmt_vector_cfloat sync_symbol1, pmt_vector_cfloat sync_symbol2, int n_data_symbols, 
        int eq_noise_red_len=0, int max_carr_offset=-1, bool force_one_sync_symbol=False) -> ofdm_chanest_vcvc_sptr

    Params: (sync_symbol1, sync_symbol2, n_data_symbols, eq_noise_red_len, max_carr_offset, force_one_sync_symbol)
    """
  return _howto_swig.ofdm_chanest_vcvc_make(*args, **kwargs)

class ofdm_chanest_vcvc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::ofdm_chanest_vcvc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::ofdm_chanest_vcvc)> self) -> ofdm_chanest_vcvc_sptr
        __init__(boost::shared_ptr<(gr::howto::ofdm_chanest_vcvc)> self, ofdm_chanest_vcvc p) -> ofdm_chanest_vcvc_sptr
        """
        this = _howto_swig.new_ofdm_chanest_vcvc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_chanest_vcvc_sptr self) -> ofdm_chanest_vcvc"""
        return _howto_swig.ofdm_chanest_vcvc_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_ofdm_chanest_vcvc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_chanest_vcvc_sptr self, pmt_vector_cfloat sync_symbol1, pmt_vector_cfloat sync_symbol2, int n_data_symbols, 
            int eq_noise_red_len=0, int max_carr_offset=-1, bool force_one_sync_symbol=False) -> ofdm_chanest_vcvc_sptr

        Params: (sync_symbol1, sync_symbol2, n_data_symbols, eq_noise_red_len, max_carr_offset, force_one_sync_symbol)
        """
        return _howto_swig.ofdm_chanest_vcvc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_chanest_vcvc_sptr self) -> unsigned int"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_chanest_vcvc_sptr self, int which, int delay)
        declare_sample_delay(ofdm_chanest_vcvc_sptr self, unsigned int delay)
        """
        return _howto_swig.ofdm_chanest_vcvc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_chanest_vcvc_sptr self, int which) -> unsigned int"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_chanest_vcvc_sptr self) -> int"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_chanest_vcvc_sptr self) -> double"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_chanest_vcvc_sptr self) -> bool"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_start(self)

    def stop(self):
        """stop(ofdm_chanest_vcvc_sptr self) -> bool"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_chanest_vcvc_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_chanest_vcvc_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_chanest_vcvc_sptr self) -> int"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_chanest_vcvc_sptr self, int m)"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_chanest_vcvc_sptr self)"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_chanest_vcvc_sptr self) -> bool"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_chanest_vcvc_sptr self, int m)"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_chanest_vcvc_sptr self) -> int"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_chanest_vcvc_sptr self, int i) -> long"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_chanest_vcvc_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_chanest_vcvc_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.ofdm_chanest_vcvc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_chanest_vcvc_sptr self, int i) -> long"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_chanest_vcvc_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_chanest_vcvc_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.ofdm_chanest_vcvc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_chanest_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_chanest_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_chanest_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_chanest_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_chanest_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_chanest_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_chanest_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_chanest_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_chanest_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_chanest_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_chanest_vcvc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_chanest_vcvc_sptr self)"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_chanest_vcvc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_chanest_vcvc_sptr self) -> int"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_chanest_vcvc_sptr self) -> int"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_chanest_vcvc_sptr self, int priority) -> int"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_chanest_vcvc_sptr self) -> std::string"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_chanest_vcvc_sptr self) -> std::string"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_chanest_vcvc_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_chanest_vcvc_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_chanest_vcvc_sptr self) -> long"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_chanest_vcvc_sptr self) -> basic_block_sptr"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_chanest_vcvc_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_chanest_vcvc_sptr self) -> std::string"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_chanest_vcvc_sptr self, std::string name)"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_chanest_vcvc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.ofdm_chanest_vcvc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_chanest_vcvc_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_chanest_vcvc_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_chanest_vcvc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.ofdm_chanest_vcvc_sptr_message_subscribers(self, *args, **kwargs)

ofdm_chanest_vcvc_sptr_swigregister = _howto_swig.ofdm_chanest_vcvc_sptr_swigregister
ofdm_chanest_vcvc_sptr_swigregister(ofdm_chanest_vcvc_sptr)

ofdm_chanest_vcvc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_chanest_vcvc = ofdm_chanest_vcvc.make;

class txt_sink(object):
    """<+description of block+>"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int n_data) -> txt_sink_sptr

        Return a shared_ptr to a new instance of howto::txt_sink.

        To avoid accidental use of raw pointers, howto::txt_sink's constructor is in a private implementation class. howto::txt_sink::make is the public interface for creating new instances.

        Params: (n_data)
        """
        return _howto_swig.txt_sink_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_txt_sink
    __del__ = lambda self : None;
txt_sink_swigregister = _howto_swig.txt_sink_swigregister
txt_sink_swigregister(txt_sink)

def txt_sink_make(*args, **kwargs):
  """
    txt_sink_make(int n_data) -> txt_sink_sptr

    Return a shared_ptr to a new instance of howto::txt_sink.

    To avoid accidental use of raw pointers, howto::txt_sink's constructor is in a private implementation class. howto::txt_sink::make is the public interface for creating new instances.

    Params: (n_data)
    """
  return _howto_swig.txt_sink_make(*args, **kwargs)

class txt_sink_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::txt_sink)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::txt_sink)> self) -> txt_sink_sptr
        __init__(boost::shared_ptr<(gr::howto::txt_sink)> self, txt_sink p) -> txt_sink_sptr
        """
        this = _howto_swig.new_txt_sink_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(txt_sink_sptr self) -> txt_sink"""
        return _howto_swig.txt_sink_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_txt_sink_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(txt_sink_sptr self, int n_data) -> txt_sink_sptr

        Return a shared_ptr to a new instance of howto::txt_sink.

        To avoid accidental use of raw pointers, howto::txt_sink's constructor is in a private implementation class. howto::txt_sink::make is the public interface for creating new instances.

        Params: (n_data)
        """
        return _howto_swig.txt_sink_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(txt_sink_sptr self) -> unsigned int"""
        return _howto_swig.txt_sink_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(txt_sink_sptr self, int which, int delay)
        declare_sample_delay(txt_sink_sptr self, unsigned int delay)
        """
        return _howto_swig.txt_sink_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(txt_sink_sptr self, int which) -> unsigned int"""
        return _howto_swig.txt_sink_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(txt_sink_sptr self) -> int"""
        return _howto_swig.txt_sink_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(txt_sink_sptr self) -> double"""
        return _howto_swig.txt_sink_sptr_relative_rate(self)

    def start(self):
        """start(txt_sink_sptr self) -> bool"""
        return _howto_swig.txt_sink_sptr_start(self)

    def stop(self):
        """stop(txt_sink_sptr self) -> bool"""
        return _howto_swig.txt_sink_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(txt_sink_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.txt_sink_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(txt_sink_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.txt_sink_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(txt_sink_sptr self) -> int"""
        return _howto_swig.txt_sink_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(txt_sink_sptr self, int m)"""
        return _howto_swig.txt_sink_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(txt_sink_sptr self)"""
        return _howto_swig.txt_sink_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(txt_sink_sptr self) -> bool"""
        return _howto_swig.txt_sink_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(txt_sink_sptr self, int m)"""
        return _howto_swig.txt_sink_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(txt_sink_sptr self) -> int"""
        return _howto_swig.txt_sink_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(txt_sink_sptr self, int i) -> long"""
        return _howto_swig.txt_sink_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(txt_sink_sptr self, long max_output_buffer)
        set_max_output_buffer(txt_sink_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.txt_sink_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(txt_sink_sptr self, int i) -> long"""
        return _howto_swig.txt_sink_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(txt_sink_sptr self, long min_output_buffer)
        set_min_output_buffer(txt_sink_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.txt_sink_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(txt_sink_sptr self) -> float"""
        return _howto_swig.txt_sink_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(txt_sink_sptr self) -> float"""
        return _howto_swig.txt_sink_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(txt_sink_sptr self) -> float"""
        return _howto_swig.txt_sink_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(txt_sink_sptr self) -> float"""
        return _howto_swig.txt_sink_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(txt_sink_sptr self) -> float"""
        return _howto_swig.txt_sink_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(txt_sink_sptr self) -> float"""
        return _howto_swig.txt_sink_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(txt_sink_sptr self, int which) -> float
        pc_input_buffers_full(txt_sink_sptr self) -> pmt_vector_float
        """
        return _howto_swig.txt_sink_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(txt_sink_sptr self, int which) -> float
        pc_input_buffers_full_avg(txt_sink_sptr self) -> pmt_vector_float
        """
        return _howto_swig.txt_sink_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(txt_sink_sptr self, int which) -> float
        pc_input_buffers_full_var(txt_sink_sptr self) -> pmt_vector_float
        """
        return _howto_swig.txt_sink_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(txt_sink_sptr self, int which) -> float
        pc_output_buffers_full(txt_sink_sptr self) -> pmt_vector_float
        """
        return _howto_swig.txt_sink_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(txt_sink_sptr self, int which) -> float
        pc_output_buffers_full_avg(txt_sink_sptr self) -> pmt_vector_float
        """
        return _howto_swig.txt_sink_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(txt_sink_sptr self, int which) -> float
        pc_output_buffers_full_var(txt_sink_sptr self) -> pmt_vector_float
        """
        return _howto_swig.txt_sink_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(txt_sink_sptr self) -> float"""
        return _howto_swig.txt_sink_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(txt_sink_sptr self) -> float"""
        return _howto_swig.txt_sink_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(txt_sink_sptr self) -> float"""
        return _howto_swig.txt_sink_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(txt_sink_sptr self) -> float"""
        return _howto_swig.txt_sink_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(txt_sink_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.txt_sink_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(txt_sink_sptr self)"""
        return _howto_swig.txt_sink_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(txt_sink_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.txt_sink_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(txt_sink_sptr self) -> int"""
        return _howto_swig.txt_sink_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(txt_sink_sptr self) -> int"""
        return _howto_swig.txt_sink_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(txt_sink_sptr self, int priority) -> int"""
        return _howto_swig.txt_sink_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(txt_sink_sptr self) -> std::string"""
        return _howto_swig.txt_sink_sptr_name(self)

    def symbol_name(self):
        """symbol_name(txt_sink_sptr self) -> std::string"""
        return _howto_swig.txt_sink_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(txt_sink_sptr self) -> io_signature_sptr"""
        return _howto_swig.txt_sink_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(txt_sink_sptr self) -> io_signature_sptr"""
        return _howto_swig.txt_sink_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(txt_sink_sptr self) -> long"""
        return _howto_swig.txt_sink_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(txt_sink_sptr self) -> basic_block_sptr"""
        return _howto_swig.txt_sink_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(txt_sink_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.txt_sink_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(txt_sink_sptr self) -> std::string"""
        return _howto_swig.txt_sink_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(txt_sink_sptr self, std::string name)"""
        return _howto_swig.txt_sink_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(txt_sink_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.txt_sink_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(txt_sink_sptr self) -> swig_int_ptr"""
        return _howto_swig.txt_sink_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(txt_sink_sptr self) -> swig_int_ptr"""
        return _howto_swig.txt_sink_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(txt_sink_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.txt_sink_sptr_message_subscribers(self, *args, **kwargs)

txt_sink_sptr_swigregister = _howto_swig.txt_sink_sptr_swigregister
txt_sink_sptr_swigregister(txt_sink_sptr)

txt_sink_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
txt_sink = txt_sink.make;

class header_payload_demux(object):
    """
    Header/Payload demuxer.

    This block is designed to handle packets from a bursty transmission. Input 0 takes a continuous transmission of samples. If used, input 1 is a trigger signal. In this case, a 1 on input 1 is a trigger. Otherwise, a tag with the key specified in  is used as a trigger (its value is irrelevant).

    Until a trigger signal is detected, all samples are dropped onto the floor. Once a trigger is detected, a total of  items are copied to output 0. The block then stalls until it receives a message on the message port . The message must be a PMT dictionary; all key/value pairs are copied as tags to the first item of the payload (which is assumed to be the first item after the header). The value corresponding to the key specified in  is read and taken as the payload length. The payload, together with the header data as tags, is then copied to output 1.

    If specified,  items are discarded before every symbol. This is useful for demuxing bursts of OFDM signals.

    Any tags on the input stream are copied to the corresponding output  they're on an item that is propagated. Note that a tag on the header items is copied to the header stream; that means the header-parsing block must handle these tags if they should go on the payload. A special case are tags on items that make up the guard interval. These are copied to the first item of the following symbol.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int header_len, int items_per_symbol, int guard_interval=0, std::string const & length_tag_key="frame_len", 
            std::string const & trigger_tag_key="", bool output_symbols=False, 
            size_t itemsize=sizeof(gr_complex), std::string const & timing_tag_key="", 
            double const samp_rate=1.0, std::vector< std::string,std::allocator< std::string > > const & special_tags=std::vector< std::string >()) -> header_payload_demux_sptr

        Params: (header_len, items_per_symbol, guard_interval, length_tag_key, trigger_tag_key, output_symbols, itemsize, timing_tag_key, samp_rate, special_tags)
        """
        return _howto_swig.header_payload_demux_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_header_payload_demux
    __del__ = lambda self : None;
header_payload_demux_swigregister = _howto_swig.header_payload_demux_swigregister
header_payload_demux_swigregister(header_payload_demux)

def header_payload_demux_make(*args, **kwargs):
  """
    header_payload_demux_make(int header_len, int items_per_symbol, int guard_interval=0, std::string const & length_tag_key="frame_len", 
        std::string const & trigger_tag_key="", bool output_symbols=False, 
        size_t itemsize=sizeof(gr_complex), std::string const & timing_tag_key="", 
        double const samp_rate=1.0, std::vector< std::string,std::allocator< std::string > > const & special_tags=std::vector< std::string >()) -> header_payload_demux_sptr

    Params: (header_len, items_per_symbol, guard_interval, length_tag_key, trigger_tag_key, output_symbols, itemsize, timing_tag_key, samp_rate, special_tags)
    """
  return _howto_swig.header_payload_demux_make(*args, **kwargs)

class header_payload_demux_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::header_payload_demux)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::header_payload_demux)> self) -> header_payload_demux_sptr
        __init__(boost::shared_ptr<(gr::howto::header_payload_demux)> self, header_payload_demux p) -> header_payload_demux_sptr
        """
        this = _howto_swig.new_header_payload_demux_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(header_payload_demux_sptr self) -> header_payload_demux"""
        return _howto_swig.header_payload_demux_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_header_payload_demux_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(header_payload_demux_sptr self, int header_len, int items_per_symbol, int guard_interval=0, std::string const & length_tag_key="frame_len", 
            std::string const & trigger_tag_key="", bool output_symbols=False, 
            size_t itemsize=sizeof(gr_complex), std::string const & timing_tag_key="", 
            double const samp_rate=1.0, std::vector< std::string,std::allocator< std::string > > const & special_tags=std::vector< std::string >()) -> header_payload_demux_sptr

        Params: (header_len, items_per_symbol, guard_interval, length_tag_key, trigger_tag_key, output_symbols, itemsize, timing_tag_key, samp_rate, special_tags)
        """
        return _howto_swig.header_payload_demux_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(header_payload_demux_sptr self) -> unsigned int"""
        return _howto_swig.header_payload_demux_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(header_payload_demux_sptr self, int which, int delay)
        declare_sample_delay(header_payload_demux_sptr self, unsigned int delay)
        """
        return _howto_swig.header_payload_demux_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(header_payload_demux_sptr self, int which) -> unsigned int"""
        return _howto_swig.header_payload_demux_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(header_payload_demux_sptr self) -> int"""
        return _howto_swig.header_payload_demux_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(header_payload_demux_sptr self) -> double"""
        return _howto_swig.header_payload_demux_sptr_relative_rate(self)

    def start(self):
        """start(header_payload_demux_sptr self) -> bool"""
        return _howto_swig.header_payload_demux_sptr_start(self)

    def stop(self):
        """stop(header_payload_demux_sptr self) -> bool"""
        return _howto_swig.header_payload_demux_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(header_payload_demux_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.header_payload_demux_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(header_payload_demux_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.header_payload_demux_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(header_payload_demux_sptr self) -> int"""
        return _howto_swig.header_payload_demux_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(header_payload_demux_sptr self, int m)"""
        return _howto_swig.header_payload_demux_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(header_payload_demux_sptr self)"""
        return _howto_swig.header_payload_demux_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(header_payload_demux_sptr self) -> bool"""
        return _howto_swig.header_payload_demux_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(header_payload_demux_sptr self, int m)"""
        return _howto_swig.header_payload_demux_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(header_payload_demux_sptr self) -> int"""
        return _howto_swig.header_payload_demux_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(header_payload_demux_sptr self, int i) -> long"""
        return _howto_swig.header_payload_demux_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(header_payload_demux_sptr self, long max_output_buffer)
        set_max_output_buffer(header_payload_demux_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.header_payload_demux_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(header_payload_demux_sptr self, int i) -> long"""
        return _howto_swig.header_payload_demux_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(header_payload_demux_sptr self, long min_output_buffer)
        set_min_output_buffer(header_payload_demux_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.header_payload_demux_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(header_payload_demux_sptr self) -> float"""
        return _howto_swig.header_payload_demux_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(header_payload_demux_sptr self) -> float"""
        return _howto_swig.header_payload_demux_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(header_payload_demux_sptr self) -> float"""
        return _howto_swig.header_payload_demux_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(header_payload_demux_sptr self) -> float"""
        return _howto_swig.header_payload_demux_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(header_payload_demux_sptr self) -> float"""
        return _howto_swig.header_payload_demux_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(header_payload_demux_sptr self) -> float"""
        return _howto_swig.header_payload_demux_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(header_payload_demux_sptr self, int which) -> float
        pc_input_buffers_full(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _howto_swig.header_payload_demux_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(header_payload_demux_sptr self, int which) -> float
        pc_input_buffers_full_avg(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _howto_swig.header_payload_demux_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(header_payload_demux_sptr self, int which) -> float
        pc_input_buffers_full_var(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _howto_swig.header_payload_demux_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(header_payload_demux_sptr self, int which) -> float
        pc_output_buffers_full(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _howto_swig.header_payload_demux_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(header_payload_demux_sptr self, int which) -> float
        pc_output_buffers_full_avg(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _howto_swig.header_payload_demux_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(header_payload_demux_sptr self, int which) -> float
        pc_output_buffers_full_var(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _howto_swig.header_payload_demux_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(header_payload_demux_sptr self) -> float"""
        return _howto_swig.header_payload_demux_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(header_payload_demux_sptr self) -> float"""
        return _howto_swig.header_payload_demux_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(header_payload_demux_sptr self) -> float"""
        return _howto_swig.header_payload_demux_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(header_payload_demux_sptr self) -> float"""
        return _howto_swig.header_payload_demux_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(header_payload_demux_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.header_payload_demux_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(header_payload_demux_sptr self)"""
        return _howto_swig.header_payload_demux_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(header_payload_demux_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.header_payload_demux_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(header_payload_demux_sptr self) -> int"""
        return _howto_swig.header_payload_demux_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(header_payload_demux_sptr self) -> int"""
        return _howto_swig.header_payload_demux_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(header_payload_demux_sptr self, int priority) -> int"""
        return _howto_swig.header_payload_demux_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(header_payload_demux_sptr self) -> std::string"""
        return _howto_swig.header_payload_demux_sptr_name(self)

    def symbol_name(self):
        """symbol_name(header_payload_demux_sptr self) -> std::string"""
        return _howto_swig.header_payload_demux_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(header_payload_demux_sptr self) -> io_signature_sptr"""
        return _howto_swig.header_payload_demux_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(header_payload_demux_sptr self) -> io_signature_sptr"""
        return _howto_swig.header_payload_demux_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(header_payload_demux_sptr self) -> long"""
        return _howto_swig.header_payload_demux_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(header_payload_demux_sptr self) -> basic_block_sptr"""
        return _howto_swig.header_payload_demux_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(header_payload_demux_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.header_payload_demux_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(header_payload_demux_sptr self) -> std::string"""
        return _howto_swig.header_payload_demux_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(header_payload_demux_sptr self, std::string name)"""
        return _howto_swig.header_payload_demux_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(header_payload_demux_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.header_payload_demux_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(header_payload_demux_sptr self) -> swig_int_ptr"""
        return _howto_swig.header_payload_demux_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(header_payload_demux_sptr self) -> swig_int_ptr"""
        return _howto_swig.header_payload_demux_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(header_payload_demux_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.header_payload_demux_sptr_message_subscribers(self, *args, **kwargs)

header_payload_demux_sptr_swigregister = _howto_swig.header_payload_demux_sptr_swigregister
header_payload_demux_sptr_swigregister(header_payload_demux_sptr)

header_payload_demux_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
header_payload_demux = header_payload_demux.make;

class chan_info_parser(object):
    """<+description of block+>"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int fft_len) -> chan_info_parser_sptr

        Return a shared_ptr to a new instance of howto::chan_info_parser.

        To avoid accidental use of raw pointers, howto::chan_info_parser's constructor is in a private implementation class. howto::chan_info_parser::make is the public interface for creating new instances.

        Params: (fft_len)
        """
        return _howto_swig.chan_info_parser_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_chan_info_parser
    __del__ = lambda self : None;
chan_info_parser_swigregister = _howto_swig.chan_info_parser_swigregister
chan_info_parser_swigregister(chan_info_parser)

def chan_info_parser_make(*args, **kwargs):
  """
    chan_info_parser_make(int fft_len) -> chan_info_parser_sptr

    Return a shared_ptr to a new instance of howto::chan_info_parser.

    To avoid accidental use of raw pointers, howto::chan_info_parser's constructor is in a private implementation class. howto::chan_info_parser::make is the public interface for creating new instances.

    Params: (fft_len)
    """
  return _howto_swig.chan_info_parser_make(*args, **kwargs)

class chan_info_parser_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::chan_info_parser)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::chan_info_parser)> self) -> chan_info_parser_sptr
        __init__(boost::shared_ptr<(gr::howto::chan_info_parser)> self, chan_info_parser p) -> chan_info_parser_sptr
        """
        this = _howto_swig.new_chan_info_parser_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(chan_info_parser_sptr self) -> chan_info_parser"""
        return _howto_swig.chan_info_parser_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_chan_info_parser_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(chan_info_parser_sptr self, int fft_len) -> chan_info_parser_sptr

        Return a shared_ptr to a new instance of howto::chan_info_parser.

        To avoid accidental use of raw pointers, howto::chan_info_parser's constructor is in a private implementation class. howto::chan_info_parser::make is the public interface for creating new instances.

        Params: (fft_len)
        """
        return _howto_swig.chan_info_parser_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(chan_info_parser_sptr self) -> unsigned int"""
        return _howto_swig.chan_info_parser_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(chan_info_parser_sptr self, int which, int delay)
        declare_sample_delay(chan_info_parser_sptr self, unsigned int delay)
        """
        return _howto_swig.chan_info_parser_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(chan_info_parser_sptr self, int which) -> unsigned int"""
        return _howto_swig.chan_info_parser_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(chan_info_parser_sptr self) -> int"""
        return _howto_swig.chan_info_parser_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(chan_info_parser_sptr self) -> double"""
        return _howto_swig.chan_info_parser_sptr_relative_rate(self)

    def start(self):
        """start(chan_info_parser_sptr self) -> bool"""
        return _howto_swig.chan_info_parser_sptr_start(self)

    def stop(self):
        """stop(chan_info_parser_sptr self) -> bool"""
        return _howto_swig.chan_info_parser_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(chan_info_parser_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.chan_info_parser_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(chan_info_parser_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.chan_info_parser_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(chan_info_parser_sptr self) -> int"""
        return _howto_swig.chan_info_parser_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(chan_info_parser_sptr self, int m)"""
        return _howto_swig.chan_info_parser_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(chan_info_parser_sptr self)"""
        return _howto_swig.chan_info_parser_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(chan_info_parser_sptr self) -> bool"""
        return _howto_swig.chan_info_parser_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(chan_info_parser_sptr self, int m)"""
        return _howto_swig.chan_info_parser_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(chan_info_parser_sptr self) -> int"""
        return _howto_swig.chan_info_parser_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(chan_info_parser_sptr self, int i) -> long"""
        return _howto_swig.chan_info_parser_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(chan_info_parser_sptr self, long max_output_buffer)
        set_max_output_buffer(chan_info_parser_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.chan_info_parser_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(chan_info_parser_sptr self, int i) -> long"""
        return _howto_swig.chan_info_parser_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(chan_info_parser_sptr self, long min_output_buffer)
        set_min_output_buffer(chan_info_parser_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.chan_info_parser_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(chan_info_parser_sptr self) -> float"""
        return _howto_swig.chan_info_parser_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(chan_info_parser_sptr self) -> float"""
        return _howto_swig.chan_info_parser_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(chan_info_parser_sptr self) -> float"""
        return _howto_swig.chan_info_parser_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(chan_info_parser_sptr self) -> float"""
        return _howto_swig.chan_info_parser_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(chan_info_parser_sptr self) -> float"""
        return _howto_swig.chan_info_parser_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(chan_info_parser_sptr self) -> float"""
        return _howto_swig.chan_info_parser_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(chan_info_parser_sptr self, int which) -> float
        pc_input_buffers_full(chan_info_parser_sptr self) -> pmt_vector_float
        """
        return _howto_swig.chan_info_parser_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(chan_info_parser_sptr self, int which) -> float
        pc_input_buffers_full_avg(chan_info_parser_sptr self) -> pmt_vector_float
        """
        return _howto_swig.chan_info_parser_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(chan_info_parser_sptr self, int which) -> float
        pc_input_buffers_full_var(chan_info_parser_sptr self) -> pmt_vector_float
        """
        return _howto_swig.chan_info_parser_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(chan_info_parser_sptr self, int which) -> float
        pc_output_buffers_full(chan_info_parser_sptr self) -> pmt_vector_float
        """
        return _howto_swig.chan_info_parser_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(chan_info_parser_sptr self, int which) -> float
        pc_output_buffers_full_avg(chan_info_parser_sptr self) -> pmt_vector_float
        """
        return _howto_swig.chan_info_parser_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(chan_info_parser_sptr self, int which) -> float
        pc_output_buffers_full_var(chan_info_parser_sptr self) -> pmt_vector_float
        """
        return _howto_swig.chan_info_parser_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(chan_info_parser_sptr self) -> float"""
        return _howto_swig.chan_info_parser_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(chan_info_parser_sptr self) -> float"""
        return _howto_swig.chan_info_parser_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(chan_info_parser_sptr self) -> float"""
        return _howto_swig.chan_info_parser_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(chan_info_parser_sptr self) -> float"""
        return _howto_swig.chan_info_parser_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(chan_info_parser_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.chan_info_parser_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(chan_info_parser_sptr self)"""
        return _howto_swig.chan_info_parser_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(chan_info_parser_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.chan_info_parser_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(chan_info_parser_sptr self) -> int"""
        return _howto_swig.chan_info_parser_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(chan_info_parser_sptr self) -> int"""
        return _howto_swig.chan_info_parser_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(chan_info_parser_sptr self, int priority) -> int"""
        return _howto_swig.chan_info_parser_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(chan_info_parser_sptr self) -> std::string"""
        return _howto_swig.chan_info_parser_sptr_name(self)

    def symbol_name(self):
        """symbol_name(chan_info_parser_sptr self) -> std::string"""
        return _howto_swig.chan_info_parser_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(chan_info_parser_sptr self) -> io_signature_sptr"""
        return _howto_swig.chan_info_parser_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(chan_info_parser_sptr self) -> io_signature_sptr"""
        return _howto_swig.chan_info_parser_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(chan_info_parser_sptr self) -> long"""
        return _howto_swig.chan_info_parser_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(chan_info_parser_sptr self) -> basic_block_sptr"""
        return _howto_swig.chan_info_parser_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(chan_info_parser_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.chan_info_parser_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(chan_info_parser_sptr self) -> std::string"""
        return _howto_swig.chan_info_parser_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(chan_info_parser_sptr self, std::string name)"""
        return _howto_swig.chan_info_parser_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(chan_info_parser_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.chan_info_parser_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(chan_info_parser_sptr self) -> swig_int_ptr"""
        return _howto_swig.chan_info_parser_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(chan_info_parser_sptr self) -> swig_int_ptr"""
        return _howto_swig.chan_info_parser_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(chan_info_parser_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.chan_info_parser_sptr_message_subscribers(self, *args, **kwargs)

chan_info_parser_sptr_swigregister = _howto_swig.chan_info_parser_sptr_swigregister
chan_info_parser_sptr_swigregister(chan_info_parser_sptr)

chan_info_parser_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
chan_info_parser = chan_info_parser.make;

class ofdm_serializer_vcc(object):
    """
    Serializes complex modulations symbols from OFDM sub-carriers.

    This is the inverse block to the carrier_allocator_cvc. It outputs the complex data symbols as a tagged stream, discarding the pilot symbols.

    If given, two different tags are parsed: The first key () specifies the number of OFDM symbols in the frame at the input. The second key () specifies the number of complex symbols that are coded into this frame. If given, this second key is then used at the output, otherwise,  is used. If both are given, the packet length specifies the maximum number of output items, and the frame length specifies the exact number of consumed input items.

    It is possible to correct a carrier offset in this function by passing another tag with said offset.

    Input: Complex vectors of length  Output: Complex scalars, in the same order as specified in occupied_carriers.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args):
        """
        make(int fft_len, std::string const & len_tag_key="frame_len", std::string const & packet_len_tag_key="", 
            int symbols_skipped=0, std::string const & carr_offset_key="", 
            bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr
        make(ofdm_carrier_allocator_cvc_sptr allocator, std::string const & packet_len_tag_key="", 
            int symbols_skipped=0, std::string const & carr_offset_key="", bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr

        Params: (fft_len, len_tag_key, packet_len_tag_key, symbols_skipped, carr_offset_key, input_is_shifted)
        """
        return _howto_swig.ofdm_serializer_vcc_make(*args)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_ofdm_serializer_vcc
    __del__ = lambda self : None;
ofdm_serializer_vcc_swigregister = _howto_swig.ofdm_serializer_vcc_swigregister
ofdm_serializer_vcc_swigregister(ofdm_serializer_vcc)

def ofdm_serializer_vcc_make(*args):
  """
    make(int fft_len, std::string const & len_tag_key="frame_len", std::string const & packet_len_tag_key="", 
        int symbols_skipped=0, std::string const & carr_offset_key="", 
        bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr
    ofdm_serializer_vcc_make(ofdm_carrier_allocator_cvc_sptr allocator, std::string const & packet_len_tag_key="", 
        int symbols_skipped=0, std::string const & carr_offset_key="", bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr

    Params: (fft_len, len_tag_key, packet_len_tag_key, symbols_skipped, carr_offset_key, input_is_shifted)
    """
  return _howto_swig.ofdm_serializer_vcc_make(*args)

class ofdm_serializer_vcc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::ofdm_serializer_vcc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::ofdm_serializer_vcc)> self) -> ofdm_serializer_vcc_sptr
        __init__(boost::shared_ptr<(gr::howto::ofdm_serializer_vcc)> self, ofdm_serializer_vcc p) -> ofdm_serializer_vcc_sptr
        """
        this = _howto_swig.new_ofdm_serializer_vcc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_serializer_vcc_sptr self) -> ofdm_serializer_vcc"""
        return _howto_swig.ofdm_serializer_vcc_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_ofdm_serializer_vcc_sptr
    __del__ = lambda self : None;
    def make(self, *args):
        """
        make(ofdm_serializer_vcc_sptr self, int fft_len, std::string const & len_tag_key="frame_len", std::string const & packet_len_tag_key="", 
            int symbols_skipped=0, std::string const & carr_offset_key="", 
            bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr
        make(ofdm_serializer_vcc_sptr self, ofdm_carrier_allocator_cvc_sptr allocator, std::string const & packet_len_tag_key="", 
            int symbols_skipped=0, std::string const & carr_offset_key="", bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr

        Params: (fft_len, len_tag_key, packet_len_tag_key, symbols_skipped, carr_offset_key, input_is_shifted)
        """
        return _howto_swig.ofdm_serializer_vcc_sptr_make(self, *args)

    def history(self):
        """history(ofdm_serializer_vcc_sptr self) -> unsigned int"""
        return _howto_swig.ofdm_serializer_vcc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_serializer_vcc_sptr self, int which, int delay)
        declare_sample_delay(ofdm_serializer_vcc_sptr self, unsigned int delay)
        """
        return _howto_swig.ofdm_serializer_vcc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_serializer_vcc_sptr self, int which) -> unsigned int"""
        return _howto_swig.ofdm_serializer_vcc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_serializer_vcc_sptr self) -> int"""
        return _howto_swig.ofdm_serializer_vcc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_serializer_vcc_sptr self) -> double"""
        return _howto_swig.ofdm_serializer_vcc_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_serializer_vcc_sptr self) -> bool"""
        return _howto_swig.ofdm_serializer_vcc_sptr_start(self)

    def stop(self):
        """stop(ofdm_serializer_vcc_sptr self) -> bool"""
        return _howto_swig.ofdm_serializer_vcc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_serializer_vcc_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.ofdm_serializer_vcc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_serializer_vcc_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.ofdm_serializer_vcc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_serializer_vcc_sptr self) -> int"""
        return _howto_swig.ofdm_serializer_vcc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_serializer_vcc_sptr self, int m)"""
        return _howto_swig.ofdm_serializer_vcc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_serializer_vcc_sptr self)"""
        return _howto_swig.ofdm_serializer_vcc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_serializer_vcc_sptr self) -> bool"""
        return _howto_swig.ofdm_serializer_vcc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_serializer_vcc_sptr self, int m)"""
        return _howto_swig.ofdm_serializer_vcc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_serializer_vcc_sptr self) -> int"""
        return _howto_swig.ofdm_serializer_vcc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_serializer_vcc_sptr self, int i) -> long"""
        return _howto_swig.ofdm_serializer_vcc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_serializer_vcc_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_serializer_vcc_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.ofdm_serializer_vcc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_serializer_vcc_sptr self, int i) -> long"""
        return _howto_swig.ofdm_serializer_vcc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_serializer_vcc_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_serializer_vcc_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.ofdm_serializer_vcc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_serializer_vcc_sptr self) -> float"""
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_serializer_vcc_sptr self) -> float"""
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_serializer_vcc_sptr self) -> float"""
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_serializer_vcc_sptr self) -> float"""
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_serializer_vcc_sptr self) -> float"""
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_serializer_vcc_sptr self) -> float"""
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_serializer_vcc_sptr self) -> float"""
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_serializer_vcc_sptr self) -> float"""
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_serializer_vcc_sptr self) -> float"""
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_serializer_vcc_sptr self) -> float"""
        return _howto_swig.ofdm_serializer_vcc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_serializer_vcc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.ofdm_serializer_vcc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_serializer_vcc_sptr self)"""
        return _howto_swig.ofdm_serializer_vcc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_serializer_vcc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.ofdm_serializer_vcc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_serializer_vcc_sptr self) -> int"""
        return _howto_swig.ofdm_serializer_vcc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_serializer_vcc_sptr self) -> int"""
        return _howto_swig.ofdm_serializer_vcc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_serializer_vcc_sptr self, int priority) -> int"""
        return _howto_swig.ofdm_serializer_vcc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_serializer_vcc_sptr self) -> std::string"""
        return _howto_swig.ofdm_serializer_vcc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_serializer_vcc_sptr self) -> std::string"""
        return _howto_swig.ofdm_serializer_vcc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_serializer_vcc_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_serializer_vcc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_serializer_vcc_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_serializer_vcc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_serializer_vcc_sptr self) -> long"""
        return _howto_swig.ofdm_serializer_vcc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_serializer_vcc_sptr self) -> basic_block_sptr"""
        return _howto_swig.ofdm_serializer_vcc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_serializer_vcc_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.ofdm_serializer_vcc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_serializer_vcc_sptr self) -> std::string"""
        return _howto_swig.ofdm_serializer_vcc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_serializer_vcc_sptr self, std::string name)"""
        return _howto_swig.ofdm_serializer_vcc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_serializer_vcc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.ofdm_serializer_vcc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_serializer_vcc_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_serializer_vcc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_serializer_vcc_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_serializer_vcc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_serializer_vcc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.ofdm_serializer_vcc_sptr_message_subscribers(self, *args, **kwargs)

ofdm_serializer_vcc_sptr_swigregister = _howto_swig.ofdm_serializer_vcc_sptr_swigregister
ofdm_serializer_vcc_sptr_swigregister(ofdm_serializer_vcc_sptr)

ofdm_serializer_vcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_serializer_vcc = ofdm_serializer_vcc.make;

class ofdm_cyclic_prefixer(object):
    """
    Adds a cyclic prefix and performs pulse shaping on OFDM symbols.

    Input: OFDM symbols (in the time domain, i.e. after the IFFT). Optionally, entire frames can be processed. In this case,  must be specified which holds the key of the tag that denotes how many OFDM symbols are in a frame. Output: A stream of (scalar) complex symbols, which include the cyclic prefix and the pulse shaping. Note: If complete frames are processed, and  is greater than zero, the final OFDM symbol is followed by the delay line of the pulse shaping.

    The pulse shape is a raised cosine in the time domain.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(size_t input_size, size_t output_size, int rolloff_len=0, std::string const & len_tag_key="") -> ofdm_cyclic_prefixer_sptr

        Params: (input_size, output_size, rolloff_len, len_tag_key)
        """
        return _howto_swig.ofdm_cyclic_prefixer_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_ofdm_cyclic_prefixer
    __del__ = lambda self : None;
ofdm_cyclic_prefixer_swigregister = _howto_swig.ofdm_cyclic_prefixer_swigregister
ofdm_cyclic_prefixer_swigregister(ofdm_cyclic_prefixer)

def ofdm_cyclic_prefixer_make(*args, **kwargs):
  """
    ofdm_cyclic_prefixer_make(size_t input_size, size_t output_size, int rolloff_len=0, std::string const & len_tag_key="") -> ofdm_cyclic_prefixer_sptr

    Params: (input_size, output_size, rolloff_len, len_tag_key)
    """
  return _howto_swig.ofdm_cyclic_prefixer_make(*args, **kwargs)

class ofdm_cyclic_prefixer_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::ofdm_cyclic_prefixer)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::ofdm_cyclic_prefixer)> self) -> ofdm_cyclic_prefixer_sptr
        __init__(boost::shared_ptr<(gr::howto::ofdm_cyclic_prefixer)> self, ofdm_cyclic_prefixer p) -> ofdm_cyclic_prefixer_sptr
        """
        this = _howto_swig.new_ofdm_cyclic_prefixer_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_cyclic_prefixer_sptr self) -> ofdm_cyclic_prefixer"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_ofdm_cyclic_prefixer_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_cyclic_prefixer_sptr self, size_t input_size, size_t output_size, int rolloff_len=0, std::string const & len_tag_key="") -> ofdm_cyclic_prefixer_sptr

        Params: (input_size, output_size, rolloff_len, len_tag_key)
        """
        return _howto_swig.ofdm_cyclic_prefixer_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_cyclic_prefixer_sptr self) -> unsigned int"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_cyclic_prefixer_sptr self, int which, int delay)
        declare_sample_delay(ofdm_cyclic_prefixer_sptr self, unsigned int delay)
        """
        return _howto_swig.ofdm_cyclic_prefixer_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_cyclic_prefixer_sptr self, int which) -> unsigned int"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_cyclic_prefixer_sptr self) -> int"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_cyclic_prefixer_sptr self) -> double"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_cyclic_prefixer_sptr self) -> bool"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_start(self)

    def stop(self):
        """stop(ofdm_cyclic_prefixer_sptr self) -> bool"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_cyclic_prefixer_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_cyclic_prefixer_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_cyclic_prefixer_sptr self) -> int"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_cyclic_prefixer_sptr self, int m)"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_cyclic_prefixer_sptr self)"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_cyclic_prefixer_sptr self) -> bool"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_cyclic_prefixer_sptr self, int m)"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_cyclic_prefixer_sptr self) -> int"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_cyclic_prefixer_sptr self, int i) -> long"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_cyclic_prefixer_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_cyclic_prefixer_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.ofdm_cyclic_prefixer_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_cyclic_prefixer_sptr self, int i) -> long"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_cyclic_prefixer_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_cyclic_prefixer_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.ofdm_cyclic_prefixer_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_cyclic_prefixer_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_cyclic_prefixer_sptr self)"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_cyclic_prefixer_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_cyclic_prefixer_sptr self) -> int"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_cyclic_prefixer_sptr self) -> int"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_cyclic_prefixer_sptr self, int priority) -> int"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_cyclic_prefixer_sptr self) -> std::string"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_cyclic_prefixer_sptr self) -> std::string"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_cyclic_prefixer_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_cyclic_prefixer_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_cyclic_prefixer_sptr self) -> long"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_cyclic_prefixer_sptr self) -> basic_block_sptr"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_cyclic_prefixer_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_cyclic_prefixer_sptr self) -> std::string"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_cyclic_prefixer_sptr self, std::string name)"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_cyclic_prefixer_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_cyclic_prefixer_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_cyclic_prefixer_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_cyclic_prefixer_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.ofdm_cyclic_prefixer_sptr_message_subscribers(self, *args, **kwargs)

ofdm_cyclic_prefixer_sptr_swigregister = _howto_swig.ofdm_cyclic_prefixer_sptr_swigregister
ofdm_cyclic_prefixer_sptr_swigregister(ofdm_cyclic_prefixer_sptr)

ofdm_cyclic_prefixer_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_cyclic_prefixer = ofdm_cyclic_prefixer.make;

class ofdm_frame_equalizer_vcvc(object):
    """
    OFDM frame equalizer.

    Performs equalization in one or two dimensions on a tagged OFDM frame.

    This does two things: First, it removes the coarse carrier offset. If a tag is found on the first item with the key 'ofdm_sync_carr_offset', this is interpreted as the coarse frequency offset in number of carriers. Next, it performs equalization in one or two dimensions on a tagged OFDM frame. The actual equalization is done by a ofdm_frame_equalizer object, outside of the block.

    Note that the tag with the coarse carrier offset is not removed. Blocks downstream from this block must not attempt to also correct this offset.

    Input: a tagged series of OFDM symbols. Output: The same as the input, but equalized and frequency-corrected.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int fft_len, unsigned int device_id, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, 
            gr_vector_vector_complexf pilot_symbols, 
            int cp_len, std::string const & len_tag_key="frame_len", 
            bool propagate_channel_state=False, 
            int fixed_frame_len=0) -> ofdm_frame_equalizer_vcvc_sptr

        Params: (fft_len, device_id, pilot_carriers, pilot_symbols, cp_len, len_tag_key, propagate_channel_state, fixed_frame_len)
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_ofdm_frame_equalizer_vcvc
    __del__ = lambda self : None;
ofdm_frame_equalizer_vcvc_swigregister = _howto_swig.ofdm_frame_equalizer_vcvc_swigregister
ofdm_frame_equalizer_vcvc_swigregister(ofdm_frame_equalizer_vcvc)

def ofdm_frame_equalizer_vcvc_make(*args, **kwargs):
  """
    ofdm_frame_equalizer_vcvc_make(int fft_len, unsigned int device_id, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, 
        gr_vector_vector_complexf pilot_symbols, 
        int cp_len, std::string const & len_tag_key="frame_len", 
        bool propagate_channel_state=False, 
        int fixed_frame_len=0) -> ofdm_frame_equalizer_vcvc_sptr

    Params: (fft_len, device_id, pilot_carriers, pilot_symbols, cp_len, len_tag_key, propagate_channel_state, fixed_frame_len)
    """
  return _howto_swig.ofdm_frame_equalizer_vcvc_make(*args, **kwargs)

class ofdm_frame_equalizer_vcvc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::ofdm_frame_equalizer_vcvc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::ofdm_frame_equalizer_vcvc)> self) -> ofdm_frame_equalizer_vcvc_sptr
        __init__(boost::shared_ptr<(gr::howto::ofdm_frame_equalizer_vcvc)> self, ofdm_frame_equalizer_vcvc p) -> ofdm_frame_equalizer_vcvc_sptr
        """
        this = _howto_swig.new_ofdm_frame_equalizer_vcvc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_frame_equalizer_vcvc_sptr self) -> ofdm_frame_equalizer_vcvc"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_ofdm_frame_equalizer_vcvc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_frame_equalizer_vcvc_sptr self, int fft_len, unsigned int device_id, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, 
            gr_vector_vector_complexf pilot_symbols, 
            int cp_len, std::string const & len_tag_key="frame_len", 
            bool propagate_channel_state=False, 
            int fixed_frame_len=0) -> ofdm_frame_equalizer_vcvc_sptr

        Params: (fft_len, device_id, pilot_carriers, pilot_symbols, cp_len, len_tag_key, propagate_channel_state, fixed_frame_len)
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_frame_equalizer_vcvc_sptr self) -> unsigned int"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_frame_equalizer_vcvc_sptr self, int which, int delay)
        declare_sample_delay(ofdm_frame_equalizer_vcvc_sptr self, unsigned int delay)
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_frame_equalizer_vcvc_sptr self, int which) -> unsigned int"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_frame_equalizer_vcvc_sptr self) -> int"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_frame_equalizer_vcvc_sptr self) -> double"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_frame_equalizer_vcvc_sptr self) -> bool"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_start(self)

    def stop(self):
        """stop(ofdm_frame_equalizer_vcvc_sptr self) -> bool"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_frame_equalizer_vcvc_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_frame_equalizer_vcvc_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_frame_equalizer_vcvc_sptr self) -> int"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_frame_equalizer_vcvc_sptr self, int m)"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_frame_equalizer_vcvc_sptr self)"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_frame_equalizer_vcvc_sptr self) -> bool"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_frame_equalizer_vcvc_sptr self, int m)"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_frame_equalizer_vcvc_sptr self) -> int"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, int i) -> long"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, int i) -> long"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_frame_equalizer_vcvc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_frame_equalizer_vcvc_sptr self)"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_frame_equalizer_vcvc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_frame_equalizer_vcvc_sptr self) -> int"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_frame_equalizer_vcvc_sptr self) -> int"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_frame_equalizer_vcvc_sptr self, int priority) -> int"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_frame_equalizer_vcvc_sptr self) -> std::string"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_frame_equalizer_vcvc_sptr self) -> std::string"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_frame_equalizer_vcvc_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_frame_equalizer_vcvc_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_frame_equalizer_vcvc_sptr self) -> long"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_frame_equalizer_vcvc_sptr self) -> basic_block_sptr"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_frame_equalizer_vcvc_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_frame_equalizer_vcvc_sptr self) -> std::string"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_frame_equalizer_vcvc_sptr self, std::string name)"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_frame_equalizer_vcvc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_frame_equalizer_vcvc_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_frame_equalizer_vcvc_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_frame_equalizer_vcvc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.ofdm_frame_equalizer_vcvc_sptr_message_subscribers(self, *args, **kwargs)

ofdm_frame_equalizer_vcvc_sptr_swigregister = _howto_swig.ofdm_frame_equalizer_vcvc_sptr_swigregister
ofdm_frame_equalizer_vcvc_sptr_swigregister(ofdm_frame_equalizer_vcvc_sptr)

ofdm_frame_equalizer_vcvc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_frame_equalizer_vcvc = ofdm_frame_equalizer_vcvc.make;

class sc_fdma_frame_equalizer_vcvc(object):
    """
    sc_fdma frame equalizer

    Performs equalization in one or two dimensions on a tagged sc_fdma frame.

    This does two things: First, it removes the coarse carrier offset. If a tag is found on the first item with the key 'sc_fdma_sync_carr_offset', this is interpreted as the coarse frequency offset in number of carriers. Next, it performs equalization in one or two dimensions on a tagged sc_fdma frame. The actual equalization is done by a sc_fdma_frame_equalizer object, outside of the block.

    Note that the tag with the coarse carrier offset is not removed. Blocks downstream from this block must not attempt to also correct this offset.

    Input: a tagged series of sc_fdma symbols. Output: The same as the input, but equalized and frequency-corrected.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(sc_fdma_equalizer_base_sptr equalizer, int cp_len, std::string const & len_tag_key="frame_len", 
            bool propagate_channel_state=False, int fixed_frame_len=0) -> sc_fdma_frame_equalizer_vcvc_sptr

        Params: (equalizer, cp_len, len_tag_key, propagate_channel_state, fixed_frame_len)
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_sc_fdma_frame_equalizer_vcvc
    __del__ = lambda self : None;
sc_fdma_frame_equalizer_vcvc_swigregister = _howto_swig.sc_fdma_frame_equalizer_vcvc_swigregister
sc_fdma_frame_equalizer_vcvc_swigregister(sc_fdma_frame_equalizer_vcvc)

def sc_fdma_frame_equalizer_vcvc_make(*args, **kwargs):
  """
    sc_fdma_frame_equalizer_vcvc_make(sc_fdma_equalizer_base_sptr equalizer, int cp_len, std::string const & len_tag_key="frame_len", 
        bool propagate_channel_state=False, int fixed_frame_len=0) -> sc_fdma_frame_equalizer_vcvc_sptr

    Params: (equalizer, cp_len, len_tag_key, propagate_channel_state, fixed_frame_len)
    """
  return _howto_swig.sc_fdma_frame_equalizer_vcvc_make(*args, **kwargs)

class sc_fdma_frame_equalizer_vcvc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::sc_fdma_frame_equalizer_vcvc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_frame_equalizer_vcvc)> self) -> sc_fdma_frame_equalizer_vcvc_sptr
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_frame_equalizer_vcvc)> self, sc_fdma_frame_equalizer_vcvc p) -> sc_fdma_frame_equalizer_vcvc_sptr
        """
        this = _howto_swig.new_sc_fdma_frame_equalizer_vcvc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(sc_fdma_frame_equalizer_vcvc_sptr self) -> sc_fdma_frame_equalizer_vcvc"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_sc_fdma_frame_equalizer_vcvc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(sc_fdma_frame_equalizer_vcvc_sptr self, sc_fdma_equalizer_base_sptr equalizer, int cp_len, std::string const & len_tag_key="frame_len", 
            bool propagate_channel_state=False, int fixed_frame_len=0) -> sc_fdma_frame_equalizer_vcvc_sptr

        Params: (equalizer, cp_len, len_tag_key, propagate_channel_state, fixed_frame_len)
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(sc_fdma_frame_equalizer_vcvc_sptr self) -> unsigned int"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(sc_fdma_frame_equalizer_vcvc_sptr self, int which, int delay)
        declare_sample_delay(sc_fdma_frame_equalizer_vcvc_sptr self, unsigned int delay)
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(sc_fdma_frame_equalizer_vcvc_sptr self, int which) -> unsigned int"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(sc_fdma_frame_equalizer_vcvc_sptr self) -> int"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(sc_fdma_frame_equalizer_vcvc_sptr self) -> double"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_relative_rate(self)

    def start(self):
        """start(sc_fdma_frame_equalizer_vcvc_sptr self) -> bool"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_start(self)

    def stop(self):
        """stop(sc_fdma_frame_equalizer_vcvc_sptr self) -> bool"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(sc_fdma_frame_equalizer_vcvc_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(sc_fdma_frame_equalizer_vcvc_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(sc_fdma_frame_equalizer_vcvc_sptr self) -> int"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(sc_fdma_frame_equalizer_vcvc_sptr self, int m)"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(sc_fdma_frame_equalizer_vcvc_sptr self)"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(sc_fdma_frame_equalizer_vcvc_sptr self) -> bool"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(sc_fdma_frame_equalizer_vcvc_sptr self, int m)"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(sc_fdma_frame_equalizer_vcvc_sptr self) -> int"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(sc_fdma_frame_equalizer_vcvc_sptr self, int i) -> long"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(sc_fdma_frame_equalizer_vcvc_sptr self, long max_output_buffer)
        set_max_output_buffer(sc_fdma_frame_equalizer_vcvc_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(sc_fdma_frame_equalizer_vcvc_sptr self, int i) -> long"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(sc_fdma_frame_equalizer_vcvc_sptr self, long min_output_buffer)
        set_min_output_buffer(sc_fdma_frame_equalizer_vcvc_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(sc_fdma_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(sc_fdma_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(sc_fdma_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(sc_fdma_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(sc_fdma_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(sc_fdma_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(sc_fdma_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_input_buffers_full(sc_fdma_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(sc_fdma_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_input_buffers_full_avg(sc_fdma_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(sc_fdma_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_input_buffers_full_var(sc_fdma_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(sc_fdma_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_output_buffers_full(sc_fdma_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(sc_fdma_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_output_buffers_full_avg(sc_fdma_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(sc_fdma_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_output_buffers_full_var(sc_fdma_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(sc_fdma_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(sc_fdma_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(sc_fdma_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(sc_fdma_frame_equalizer_vcvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(sc_fdma_frame_equalizer_vcvc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(sc_fdma_frame_equalizer_vcvc_sptr self)"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(sc_fdma_frame_equalizer_vcvc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(sc_fdma_frame_equalizer_vcvc_sptr self) -> int"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(sc_fdma_frame_equalizer_vcvc_sptr self) -> int"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(sc_fdma_frame_equalizer_vcvc_sptr self, int priority) -> int"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(sc_fdma_frame_equalizer_vcvc_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(sc_fdma_frame_equalizer_vcvc_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(sc_fdma_frame_equalizer_vcvc_sptr self) -> io_signature_sptr"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(sc_fdma_frame_equalizer_vcvc_sptr self) -> io_signature_sptr"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(sc_fdma_frame_equalizer_vcvc_sptr self) -> long"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(sc_fdma_frame_equalizer_vcvc_sptr self) -> basic_block_sptr"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(sc_fdma_frame_equalizer_vcvc_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(sc_fdma_frame_equalizer_vcvc_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(sc_fdma_frame_equalizer_vcvc_sptr self, std::string name)"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(sc_fdma_frame_equalizer_vcvc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(sc_fdma_frame_equalizer_vcvc_sptr self) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(sc_fdma_frame_equalizer_vcvc_sptr self) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(sc_fdma_frame_equalizer_vcvc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_message_subscribers(self, *args, **kwargs)

sc_fdma_frame_equalizer_vcvc_sptr_swigregister = _howto_swig.sc_fdma_frame_equalizer_vcvc_sptr_swigregister
sc_fdma_frame_equalizer_vcvc_sptr_swigregister(sc_fdma_frame_equalizer_vcvc_sptr)

sc_fdma_frame_equalizer_vcvc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
sc_fdma_frame_equalizer_vcvc = sc_fdma_frame_equalizer_vcvc.make;

class ofdm_equalizer_base_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::ofdm_equalizer_base)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::ofdm_equalizer_base)> self) -> ofdm_equalizer_base_sptr
        __init__(boost::shared_ptr<(gr::howto::ofdm_equalizer_base)> self, ofdm_equalizer_base p) -> ofdm_equalizer_base_sptr
        """
        this = _howto_swig.new_ofdm_equalizer_base_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_equalizer_base_sptr self) -> ofdm_equalizer_base"""
        return _howto_swig.ofdm_equalizer_base_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_ofdm_equalizer_base_sptr
    __del__ = lambda self : None;
    def reset(self):
        """
        reset(ofdm_equalizer_base_sptr self)

        Reset the channel information state knowledge.

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_base_sptr_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_base_sptr self, gr_complex * frame, int n_sym, int const n_symbol, int start_pos, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.

        Params: (frame, n_sym, n_symbol, start_pos, initial_taps, tags)
        """
        return _howto_swig.ofdm_equalizer_base_sptr_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(ofdm_equalizer_base_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _howto_swig.ofdm_equalizer_base_sptr_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """
        fft_len(ofdm_equalizer_base_sptr self) -> int

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_base_sptr_fft_len(self)

    def base(self):
        """
        base(ofdm_equalizer_base_sptr self) -> ofdm_equalizer_base_sptr

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_base_sptr_base(self)

ofdm_equalizer_base_sptr_swigregister = _howto_swig.ofdm_equalizer_base_sptr_swigregister
ofdm_equalizer_base_sptr_swigregister(ofdm_equalizer_base_sptr)

class ofdm_equalizer_1d_pilots_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::ofdm_equalizer_1d_pilots)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::ofdm_equalizer_1d_pilots)> self) -> ofdm_equalizer_1d_pilots_sptr
        __init__(boost::shared_ptr<(gr::howto::ofdm_equalizer_1d_pilots)> self, ofdm_equalizer_1d_pilots p) -> ofdm_equalizer_1d_pilots_sptr
        """
        this = _howto_swig.new_ofdm_equalizer_1d_pilots_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_equalizer_1d_pilots_sptr self) -> ofdm_equalizer_1d_pilots"""
        return _howto_swig.ofdm_equalizer_1d_pilots_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_ofdm_equalizer_1d_pilots_sptr
    __del__ = lambda self : None;
    def reset(self):
        """
        reset(ofdm_equalizer_1d_pilots_sptr self)

        Reset the channel information state knowledge.

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_1d_pilots_sptr_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_1d_pilots_sptr self, gr_complex * frame, int n_sym, int const n_symbol, int start_pos, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.

        Params: (frame, n_sym, n_symbol, start_pos, initial_taps, tags)
        """
        return _howto_swig.ofdm_equalizer_1d_pilots_sptr_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(ofdm_equalizer_1d_pilots_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _howto_swig.ofdm_equalizer_1d_pilots_sptr_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """
        fft_len(ofdm_equalizer_1d_pilots_sptr self) -> int

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_1d_pilots_sptr_fft_len(self)

    def base(self):
        """
        base(ofdm_equalizer_1d_pilots_sptr self) -> ofdm_equalizer_base_sptr

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_1d_pilots_sptr_base(self)

ofdm_equalizer_1d_pilots_sptr_swigregister = _howto_swig.ofdm_equalizer_1d_pilots_sptr_swigregister
ofdm_equalizer_1d_pilots_sptr_swigregister(ofdm_equalizer_1d_pilots_sptr)

ofdm_equalizer_1d_pilots_sptr.__repr__ = lambda self: "<OFDM equalizer 1D base class>"

class ofdm_equalizer_simpledfe_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::ofdm_equalizer_simpledfe)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::ofdm_equalizer_simpledfe)> self) -> ofdm_equalizer_simpledfe_sptr
        __init__(boost::shared_ptr<(gr::howto::ofdm_equalizer_simpledfe)> self, ofdm_equalizer_simpledfe p) -> ofdm_equalizer_simpledfe_sptr
        """
        this = _howto_swig.new_ofdm_equalizer_simpledfe_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_equalizer_simpledfe_sptr self) -> ofdm_equalizer_simpledfe"""
        return _howto_swig.ofdm_equalizer_simpledfe_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_ofdm_equalizer_simpledfe_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_equalizer_simpledfe_sptr self, int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            float alpha=0.1, 
            bool input_is_shifted=True) -> ofdm_equalizer_simpledfe_sptr

        Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
        """
        return _howto_swig.ofdm_equalizer_simpledfe_sptr_make(self, *args, **kwargs)

    def reset(self):
        """
        reset(ofdm_equalizer_simpledfe_sptr self)

        Reset the channel information state knowledge.

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_simpledfe_sptr_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_simpledfe_sptr self, gr_complex * frame, int n_sym, int const n_symbol, int start_pos, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.

        Params: (frame, n_sym, n_symbol, start_pos, initial_taps, tags)
        """
        return _howto_swig.ofdm_equalizer_simpledfe_sptr_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(ofdm_equalizer_simpledfe_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _howto_swig.ofdm_equalizer_simpledfe_sptr_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """
        fft_len(ofdm_equalizer_simpledfe_sptr self) -> int

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_simpledfe_sptr_fft_len(self)

    def base(self):
        """
        base(ofdm_equalizer_simpledfe_sptr self) -> ofdm_equalizer_base_sptr

        Params: (NONE)
        """
        return _howto_swig.ofdm_equalizer_simpledfe_sptr_base(self)

ofdm_equalizer_simpledfe_sptr_swigregister = _howto_swig.ofdm_equalizer_simpledfe_sptr_swigregister
ofdm_equalizer_simpledfe_sptr_swigregister(ofdm_equalizer_simpledfe_sptr)

ofdm_equalizer_simpledfe_sptr.__repr__ = lambda self: "<OFDM equalizer simpledfe>"
ofdm_equalizer_simpledfe = ofdm_equalizer_simpledfe.make;

class constellation_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::constellation)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::constellation)> self) -> constellation_sptr
        __init__(boost::shared_ptr<(gr::howto::constellation)> self, constellation p) -> constellation_sptr
        """
        this = _howto_swig.new_constellation_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_sptr self) -> constellation"""
        return _howto_swig.constellation_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_constellation_sptr
    __del__ = lambda self : None;
    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _howto_swig.constellation_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(constellation_sptr self, unsigned int value) -> pmt_vector_cfloat

        Params: (value)
        """
        return _howto_swig.constellation_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _howto_swig.constellation_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _howto_swig.constellation_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _howto_swig.constellation_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_sptr self, gr_complex const * sample, float * metric, gr::howto::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _howto_swig.constellation_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """
        calc_euclidean_metric(constellation_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """
        calc_hard_symbol_metric(constellation_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _howto_swig.constellation_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(constellation_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_arity(self)

    def base(self):
        """
        base(constellation_sptr self) -> constellation_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_base(self)

    def as_pmt(self):
        """
        as_pmt(constellation_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _howto_swig.constellation_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _howto_swig.constellation_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _howto_swig.constellation_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _howto_swig.constellation_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _howto_swig.constellation_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_sptr_swigregister = _howto_swig.constellation_sptr_swigregister
constellation_sptr_swigregister(constellation_sptr)

class constellation_calcdist_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::constellation_calcdist)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::constellation_calcdist)> self) -> constellation_calcdist_sptr
        __init__(boost::shared_ptr<(gr::howto::constellation_calcdist)> self, constellation_calcdist p) -> constellation_calcdist_sptr
        """
        this = _howto_swig.new_constellation_calcdist_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_calcdist_sptr self) -> constellation_calcdist"""
        return _howto_swig.constellation_calcdist_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_constellation_calcdist_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_calcdist_sptr self, pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int dimensionality) -> constellation_calcdist_sptr

        Make a general constellation object that calculates the Euclidean distance for hard decisions.

        Params: (constell, pre_diff_code, rotational_symmetry, dimensionality)
        """
        return _howto_swig.constellation_calcdist_sptr_make(self, *args, **kwargs)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_calcdist_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _howto_swig.constellation_calcdist_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(constellation_calcdist_sptr self, unsigned int value) -> pmt_vector_cfloat

        Params: (value)
        """
        return _howto_swig.constellation_calcdist_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_calcdist_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _howto_swig.constellation_calcdist_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_calcdist_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _howto_swig.constellation_calcdist_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_calcdist_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _howto_swig.constellation_calcdist_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_calcdist_sptr self, gr_complex const * sample, float * metric, gr::howto::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _howto_swig.constellation_calcdist_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """
        calc_euclidean_metric(constellation_calcdist_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_calcdist_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """
        calc_hard_symbol_metric(constellation_calcdist_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_calcdist_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_calcdist_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_calcdist_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_calcdist_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_calcdist_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_calcdist_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _howto_swig.constellation_calcdist_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_calcdist_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_calcdist_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_calcdist_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_calcdist_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(constellation_calcdist_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_arity(self)

    def base(self):
        """
        base(constellation_calcdist_sptr self) -> constellation_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_base(self)

    def as_pmt(self):
        """
        as_pmt(constellation_calcdist_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_calcdist_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _howto_swig.constellation_calcdist_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_calcdist_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _howto_swig.constellation_calcdist_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_calcdist_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _howto_swig.constellation_calcdist_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_calcdist_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _howto_swig.constellation_calcdist_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_calcdist_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _howto_swig.constellation_calcdist_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_calcdist_sptr_swigregister = _howto_swig.constellation_calcdist_sptr_swigregister
constellation_calcdist_sptr_swigregister(constellation_calcdist_sptr)

constellation_calcdist_sptr.__repr__ = lambda self: "<constellation calcdist (m=%d)>" % (len(self.points()))
constellation_calcdist = constellation_calcdist.make;

class constellation_rect_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::constellation_rect)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::constellation_rect)> self) -> constellation_rect_sptr
        __init__(boost::shared_ptr<(gr::howto::constellation_rect)> self, constellation_rect p) -> constellation_rect_sptr
        """
        this = _howto_swig.new_constellation_rect_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_rect_sptr self) -> constellation_rect"""
        return _howto_swig.constellation_rect_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_constellation_rect_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_rect_sptr self, pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
            float width_real_sectors, float width_imag_sectors) -> constellation_rect_sptr

        Make a rectangular constellation object.

        Params: (constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors)
        """
        return _howto_swig.constellation_rect_sptr_make(self, *args, **kwargs)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_rect_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _howto_swig.constellation_rect_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(constellation_rect_sptr self, unsigned int value) -> pmt_vector_cfloat

        Params: (value)
        """
        return _howto_swig.constellation_rect_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_rect_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _howto_swig.constellation_rect_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_rect_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _howto_swig.constellation_rect_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_rect_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _howto_swig.constellation_rect_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_rect_sptr self, gr_complex const * sample, float * metric, gr::howto::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _howto_swig.constellation_rect_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """
        calc_euclidean_metric(constellation_rect_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_rect_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """
        calc_hard_symbol_metric(constellation_rect_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_rect_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_rect_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_rect_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_rect_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_rect_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_rect_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _howto_swig.constellation_rect_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_rect_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_rect_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_rect_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_rect_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(constellation_rect_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_arity(self)

    def base(self):
        """
        base(constellation_rect_sptr self) -> constellation_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_base(self)

    def as_pmt(self):
        """
        as_pmt(constellation_rect_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_rect_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _howto_swig.constellation_rect_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_rect_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _howto_swig.constellation_rect_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_rect_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _howto_swig.constellation_rect_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_rect_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _howto_swig.constellation_rect_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_rect_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _howto_swig.constellation_rect_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_rect_sptr_swigregister = _howto_swig.constellation_rect_sptr_swigregister
constellation_rect_sptr_swigregister(constellation_rect_sptr)

constellation_rect_sptr.__repr__ = lambda self: "<constellation rect (m=%d)>" % (len(self.points()))
constellation_rect = constellation_rect.make;

class constellation_expl_rect_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::constellation_expl_rect)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::constellation_expl_rect)> self) -> constellation_expl_rect_sptr
        __init__(boost::shared_ptr<(gr::howto::constellation_expl_rect)> self, constellation_expl_rect p) -> constellation_expl_rect_sptr
        """
        this = _howto_swig.new_constellation_expl_rect_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_expl_rect_sptr self) -> constellation_expl_rect"""
        return _howto_swig.constellation_expl_rect_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_constellation_expl_rect_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_expl_rect_sptr self, pmt_vector_cfloat constellation, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
            float width_real_sectors, float width_imag_sectors, std::vector< unsigned int,std::allocator< unsigned int > > sector_values) -> constellation_expl_rect_sptr

        Params: (constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values)
        """
        return _howto_swig.constellation_expl_rect_sptr_make(self, *args, **kwargs)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_expl_rect_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _howto_swig.constellation_expl_rect_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(constellation_expl_rect_sptr self, unsigned int value) -> pmt_vector_cfloat

        Params: (value)
        """
        return _howto_swig.constellation_expl_rect_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_expl_rect_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _howto_swig.constellation_expl_rect_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_expl_rect_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _howto_swig.constellation_expl_rect_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_expl_rect_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _howto_swig.constellation_expl_rect_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_expl_rect_sptr self, gr_complex const * sample, float * metric, gr::howto::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _howto_swig.constellation_expl_rect_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """
        calc_euclidean_metric(constellation_expl_rect_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_expl_rect_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """
        calc_hard_symbol_metric(constellation_expl_rect_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_expl_rect_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_expl_rect_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_expl_rect_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_expl_rect_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_expl_rect_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_expl_rect_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _howto_swig.constellation_expl_rect_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_expl_rect_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_expl_rect_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_expl_rect_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_expl_rect_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(constellation_expl_rect_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_arity(self)

    def base(self):
        """
        base(constellation_expl_rect_sptr self) -> constellation_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_base(self)

    def as_pmt(self):
        """
        as_pmt(constellation_expl_rect_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_expl_rect_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _howto_swig.constellation_expl_rect_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_expl_rect_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _howto_swig.constellation_expl_rect_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_expl_rect_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _howto_swig.constellation_expl_rect_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_expl_rect_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _howto_swig.constellation_expl_rect_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_expl_rect_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _howto_swig.constellation_expl_rect_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_expl_rect_sptr_swigregister = _howto_swig.constellation_expl_rect_sptr_swigregister
constellation_expl_rect_sptr_swigregister(constellation_expl_rect_sptr)

constellation_expl_rect_sptr.__repr__ = lambda self: "<constellation expl rect (m=%d)>" % (len(self.points()))
constellation_expl_rect = constellation_expl_rect.make;

class constellation_psk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::constellation_psk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::constellation_psk)> self) -> constellation_psk_sptr
        __init__(boost::shared_ptr<(gr::howto::constellation_psk)> self, constellation_psk p) -> constellation_psk_sptr
        """
        this = _howto_swig.new_constellation_psk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_psk_sptr self) -> constellation_psk"""
        return _howto_swig.constellation_psk_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_constellation_psk_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_psk_sptr self, pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int n_sectors) -> constellation_psk_sptr

        Params: (constell, pre_diff_code, n_sectors)
        """
        return _howto_swig.constellation_psk_sptr_make(self, *args, **kwargs)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_psk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _howto_swig.constellation_psk_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(constellation_psk_sptr self, unsigned int value) -> pmt_vector_cfloat

        Params: (value)
        """
        return _howto_swig.constellation_psk_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_psk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _howto_swig.constellation_psk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_psk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _howto_swig.constellation_psk_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_psk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _howto_swig.constellation_psk_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_psk_sptr self, gr_complex const * sample, float * metric, gr::howto::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _howto_swig.constellation_psk_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """
        calc_euclidean_metric(constellation_psk_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_psk_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """
        calc_hard_symbol_metric(constellation_psk_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_psk_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_psk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_psk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_psk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_psk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_psk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _howto_swig.constellation_psk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_psk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_psk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_psk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_psk_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(constellation_psk_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_arity(self)

    def base(self):
        """
        base(constellation_psk_sptr self) -> constellation_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_base(self)

    def as_pmt(self):
        """
        as_pmt(constellation_psk_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_psk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _howto_swig.constellation_psk_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_psk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _howto_swig.constellation_psk_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_psk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _howto_swig.constellation_psk_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_psk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _howto_swig.constellation_psk_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_psk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _howto_swig.constellation_psk_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_psk_sptr_swigregister = _howto_swig.constellation_psk_sptr_swigregister
constellation_psk_sptr_swigregister(constellation_psk_sptr)

constellation_psk_sptr.__repr__ = lambda self: "<constellation PSK (m=%d)>" % (len(self.points()))
constellation_psk = constellation_psk.make;

class constellation_bpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::constellation_bpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::constellation_bpsk)> self) -> constellation_bpsk_sptr
        __init__(boost::shared_ptr<(gr::howto::constellation_bpsk)> self, constellation_bpsk p) -> constellation_bpsk_sptr
        """
        this = _howto_swig.new_constellation_bpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_bpsk_sptr self) -> constellation_bpsk"""
        return _howto_swig.constellation_bpsk_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_constellation_bpsk_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(constellation_bpsk_sptr self) -> constellation_bpsk_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_make(self)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_bpsk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _howto_swig.constellation_bpsk_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(constellation_bpsk_sptr self, unsigned int value) -> pmt_vector_cfloat

        Params: (value)
        """
        return _howto_swig.constellation_bpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_bpsk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _howto_swig.constellation_bpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_bpsk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _howto_swig.constellation_bpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_bpsk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _howto_swig.constellation_bpsk_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_bpsk_sptr self, gr_complex const * sample, float * metric, gr::howto::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _howto_swig.constellation_bpsk_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """
        calc_euclidean_metric(constellation_bpsk_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_bpsk_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """
        calc_hard_symbol_metric(constellation_bpsk_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_bpsk_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_bpsk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_bpsk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_bpsk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_bpsk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_bpsk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _howto_swig.constellation_bpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_bpsk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_bpsk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_bpsk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_bpsk_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(constellation_bpsk_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_arity(self)

    def base(self):
        """
        base(constellation_bpsk_sptr self) -> constellation_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_base(self)

    def as_pmt(self):
        """
        as_pmt(constellation_bpsk_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_bpsk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _howto_swig.constellation_bpsk_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_bpsk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _howto_swig.constellation_bpsk_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_bpsk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _howto_swig.constellation_bpsk_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_bpsk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _howto_swig.constellation_bpsk_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_bpsk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _howto_swig.constellation_bpsk_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_bpsk_sptr_swigregister = _howto_swig.constellation_bpsk_sptr_swigregister
constellation_bpsk_sptr_swigregister(constellation_bpsk_sptr)

constellation_bpsk_sptr.__repr__ = lambda self: "<constellation BPSK>"
constellation_bpsk = constellation_bpsk.make;

class constellation_qpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::constellation_qpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::constellation_qpsk)> self) -> constellation_qpsk_sptr
        __init__(boost::shared_ptr<(gr::howto::constellation_qpsk)> self, constellation_qpsk p) -> constellation_qpsk_sptr
        """
        this = _howto_swig.new_constellation_qpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_qpsk_sptr self) -> constellation_qpsk"""
        return _howto_swig.constellation_qpsk_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_constellation_qpsk_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(constellation_qpsk_sptr self) -> constellation_qpsk_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_make(self)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_qpsk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _howto_swig.constellation_qpsk_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(constellation_qpsk_sptr self, unsigned int value) -> pmt_vector_cfloat

        Params: (value)
        """
        return _howto_swig.constellation_qpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_qpsk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _howto_swig.constellation_qpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_qpsk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _howto_swig.constellation_qpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_qpsk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _howto_swig.constellation_qpsk_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_qpsk_sptr self, gr_complex const * sample, float * metric, gr::howto::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _howto_swig.constellation_qpsk_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """
        calc_euclidean_metric(constellation_qpsk_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_qpsk_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """
        calc_hard_symbol_metric(constellation_qpsk_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_qpsk_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_qpsk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_qpsk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_qpsk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_qpsk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_qpsk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _howto_swig.constellation_qpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_qpsk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_qpsk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_qpsk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_qpsk_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(constellation_qpsk_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_arity(self)

    def base(self):
        """
        base(constellation_qpsk_sptr self) -> constellation_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_base(self)

    def as_pmt(self):
        """
        as_pmt(constellation_qpsk_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_qpsk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _howto_swig.constellation_qpsk_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_qpsk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _howto_swig.constellation_qpsk_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_qpsk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _howto_swig.constellation_qpsk_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_qpsk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _howto_swig.constellation_qpsk_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_qpsk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _howto_swig.constellation_qpsk_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_qpsk_sptr_swigregister = _howto_swig.constellation_qpsk_sptr_swigregister
constellation_qpsk_sptr_swigregister(constellation_qpsk_sptr)

constellation_qpsk_sptr.__repr__ = lambda self: "<constellation QPSK>"
constellation_qpsk = constellation_qpsk.make;

class constellation_dqpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::constellation_dqpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::constellation_dqpsk)> self) -> constellation_dqpsk_sptr
        __init__(boost::shared_ptr<(gr::howto::constellation_dqpsk)> self, constellation_dqpsk p) -> constellation_dqpsk_sptr
        """
        this = _howto_swig.new_constellation_dqpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_dqpsk_sptr self) -> constellation_dqpsk"""
        return _howto_swig.constellation_dqpsk_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_constellation_dqpsk_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(constellation_dqpsk_sptr self) -> constellation_dqpsk_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_make(self)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_dqpsk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _howto_swig.constellation_dqpsk_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(constellation_dqpsk_sptr self, unsigned int value) -> pmt_vector_cfloat

        Params: (value)
        """
        return _howto_swig.constellation_dqpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_dqpsk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _howto_swig.constellation_dqpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_dqpsk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _howto_swig.constellation_dqpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_dqpsk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _howto_swig.constellation_dqpsk_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_dqpsk_sptr self, gr_complex const * sample, float * metric, gr::howto::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _howto_swig.constellation_dqpsk_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """
        calc_euclidean_metric(constellation_dqpsk_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_dqpsk_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """
        calc_hard_symbol_metric(constellation_dqpsk_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_dqpsk_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_dqpsk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_dqpsk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_dqpsk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_dqpsk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_dqpsk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _howto_swig.constellation_dqpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_dqpsk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_dqpsk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_dqpsk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_dqpsk_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(constellation_dqpsk_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_arity(self)

    def base(self):
        """
        base(constellation_dqpsk_sptr self) -> constellation_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_base(self)

    def as_pmt(self):
        """
        as_pmt(constellation_dqpsk_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_dqpsk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _howto_swig.constellation_dqpsk_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_dqpsk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _howto_swig.constellation_dqpsk_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_dqpsk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _howto_swig.constellation_dqpsk_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_dqpsk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _howto_swig.constellation_dqpsk_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_dqpsk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _howto_swig.constellation_dqpsk_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_dqpsk_sptr_swigregister = _howto_swig.constellation_dqpsk_sptr_swigregister
constellation_dqpsk_sptr_swigregister(constellation_dqpsk_sptr)

constellation_dqpsk_sptr.__repr__ = lambda self: "<constellation DQPSK>"
constellation_dqpsk = constellation_dqpsk.make;

class constellation_8psk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::constellation_8psk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::constellation_8psk)> self) -> constellation_8psk_sptr
        __init__(boost::shared_ptr<(gr::howto::constellation_8psk)> self, constellation_8psk p) -> constellation_8psk_sptr
        """
        this = _howto_swig.new_constellation_8psk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_8psk_sptr self) -> constellation_8psk"""
        return _howto_swig.constellation_8psk_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_constellation_8psk_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(constellation_8psk_sptr self) -> constellation_8psk_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_make(self)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_8psk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _howto_swig.constellation_8psk_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(constellation_8psk_sptr self, unsigned int value) -> pmt_vector_cfloat

        Params: (value)
        """
        return _howto_swig.constellation_8psk_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_8psk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _howto_swig.constellation_8psk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_8psk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _howto_swig.constellation_8psk_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_8psk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _howto_swig.constellation_8psk_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_8psk_sptr self, gr_complex const * sample, float * metric, gr::howto::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _howto_swig.constellation_8psk_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """
        calc_euclidean_metric(constellation_8psk_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_8psk_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """
        calc_hard_symbol_metric(constellation_8psk_sptr self, gr_complex const * sample, float * metric)

        Params: (sample, metric)
        """
        return _howto_swig.constellation_8psk_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_8psk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_8psk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_8psk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_8psk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_8psk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _howto_swig.constellation_8psk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_8psk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_8psk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_8psk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_8psk_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(constellation_8psk_sptr self) -> unsigned int

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_arity(self)

    def base(self):
        """
        base(constellation_8psk_sptr self) -> constellation_sptr

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_base(self)

    def as_pmt(self):
        """
        as_pmt(constellation_8psk_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_8psk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _howto_swig.constellation_8psk_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_8psk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _howto_swig.constellation_8psk_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_8psk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _howto_swig.constellation_8psk_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_8psk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _howto_swig.constellation_8psk_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_8psk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _howto_swig.constellation_8psk_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_8psk_sptr_swigregister = _howto_swig.constellation_8psk_sptr_swigregister
constellation_8psk_sptr_swigregister(constellation_8psk_sptr)

constellation_8psk_sptr.__repr__ = lambda self: "<constellation 8PSK>"
constellation_8psk = constellation_8psk.make;

class sc_fdma_equalizer_base_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::sc_fdma_equalizer_base)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_equalizer_base)> self) -> sc_fdma_equalizer_base_sptr
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_equalizer_base)> self, sc_fdma_equalizer_base p) -> sc_fdma_equalizer_base_sptr
        """
        this = _howto_swig.new_sc_fdma_equalizer_base_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(sc_fdma_equalizer_base_sptr self) -> sc_fdma_equalizer_base"""
        return _howto_swig.sc_fdma_equalizer_base_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_sc_fdma_equalizer_base_sptr
    __del__ = lambda self : None;
    def reset(self):
        """
        reset(sc_fdma_equalizer_base_sptr self)

        Reset the channel information state knowledge.

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_base_sptr_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(sc_fdma_equalizer_base_sptr self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.

        Params: (frame, n_sym, initial_taps, tags)
        """
        return _howto_swig.sc_fdma_equalizer_base_sptr_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(sc_fdma_equalizer_base_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _howto_swig.sc_fdma_equalizer_base_sptr_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """
        fft_len(sc_fdma_equalizer_base_sptr self) -> int

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_base_sptr_fft_len(self)

    def base(self):
        """
        base(sc_fdma_equalizer_base_sptr self) -> sc_fdma_equalizer_base_sptr

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_base_sptr_base(self)

sc_fdma_equalizer_base_sptr_swigregister = _howto_swig.sc_fdma_equalizer_base_sptr_swigregister
sc_fdma_equalizer_base_sptr_swigregister(sc_fdma_equalizer_base_sptr)

class sc_fdma_equalizer_1d_pilots_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::sc_fdma_equalizer_1d_pilots)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_equalizer_1d_pilots)> self) -> sc_fdma_equalizer_1d_pilots_sptr
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_equalizer_1d_pilots)> self, sc_fdma_equalizer_1d_pilots p) -> sc_fdma_equalizer_1d_pilots_sptr
        """
        this = _howto_swig.new_sc_fdma_equalizer_1d_pilots_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(sc_fdma_equalizer_1d_pilots_sptr self) -> sc_fdma_equalizer_1d_pilots"""
        return _howto_swig.sc_fdma_equalizer_1d_pilots_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_sc_fdma_equalizer_1d_pilots_sptr
    __del__ = lambda self : None;
    def reset(self):
        """
        reset(sc_fdma_equalizer_1d_pilots_sptr self)

        Reset the channel information state knowledge.

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_1d_pilots_sptr_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(sc_fdma_equalizer_1d_pilots_sptr self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.

        Params: (frame, n_sym, initial_taps, tags)
        """
        return _howto_swig.sc_fdma_equalizer_1d_pilots_sptr_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(sc_fdma_equalizer_1d_pilots_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _howto_swig.sc_fdma_equalizer_1d_pilots_sptr_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """
        fft_len(sc_fdma_equalizer_1d_pilots_sptr self) -> int

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_1d_pilots_sptr_fft_len(self)

    def base(self):
        """
        base(sc_fdma_equalizer_1d_pilots_sptr self) -> sc_fdma_equalizer_base_sptr

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_1d_pilots_sptr_base(self)

sc_fdma_equalizer_1d_pilots_sptr_swigregister = _howto_swig.sc_fdma_equalizer_1d_pilots_sptr_swigregister
sc_fdma_equalizer_1d_pilots_sptr_swigregister(sc_fdma_equalizer_1d_pilots_sptr)

sc_fdma_equalizer_1d_pilots_sptr.__repr__ = lambda self: "<sc_fdma equalizer 1D base class>"

class sc_fdma_equalizer_simpledfe_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::sc_fdma_equalizer_simpledfe)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_equalizer_simpledfe)> self) -> sc_fdma_equalizer_simpledfe_sptr
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_equalizer_simpledfe)> self, sc_fdma_equalizer_simpledfe p) -> sc_fdma_equalizer_simpledfe_sptr
        """
        this = _howto_swig.new_sc_fdma_equalizer_simpledfe_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(sc_fdma_equalizer_simpledfe_sptr self) -> sc_fdma_equalizer_simpledfe"""
        return _howto_swig.sc_fdma_equalizer_simpledfe_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_sc_fdma_equalizer_simpledfe_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(sc_fdma_equalizer_simpledfe_sptr self, int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            float alpha=0.1, 
            bool input_is_shifted=True) -> sc_fdma_equalizer_simpledfe_sptr

        Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
        """
        return _howto_swig.sc_fdma_equalizer_simpledfe_sptr_make(self, *args, **kwargs)

    def reset(self):
        """
        reset(sc_fdma_equalizer_simpledfe_sptr self)

        Reset the channel information state knowledge.

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_simpledfe_sptr_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(sc_fdma_equalizer_simpledfe_sptr self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.

        Params: (frame, n_sym, initial_taps, tags)
        """
        return _howto_swig.sc_fdma_equalizer_simpledfe_sptr_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(sc_fdma_equalizer_simpledfe_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _howto_swig.sc_fdma_equalizer_simpledfe_sptr_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """
        fft_len(sc_fdma_equalizer_simpledfe_sptr self) -> int

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_simpledfe_sptr_fft_len(self)

    def base(self):
        """
        base(sc_fdma_equalizer_simpledfe_sptr self) -> sc_fdma_equalizer_base_sptr

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_equalizer_simpledfe_sptr_base(self)

sc_fdma_equalizer_simpledfe_sptr_swigregister = _howto_swig.sc_fdma_equalizer_simpledfe_sptr_swigregister
sc_fdma_equalizer_simpledfe_sptr_swigregister(sc_fdma_equalizer_simpledfe_sptr)

sc_fdma_equalizer_simpledfe_sptr.__repr__ = lambda self: "<sc_fdma equalizer simpledfe>"
sc_fdma_equalizer_simpledfe = sc_fdma_equalizer_simpledfe.make;

class packet_header_default_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::packet_header_default)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::packet_header_default)> self) -> packet_header_default_sptr
        __init__(boost::shared_ptr<(gr::howto::packet_header_default)> self, packet_header_default p) -> packet_header_default_sptr
        """
        this = _howto_swig.new_packet_header_default_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(packet_header_default_sptr self) -> packet_header_default"""
        return _howto_swig.packet_header_default_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_packet_header_default_sptr
    __del__ = lambda self : None;
    def base(self):
        """
        base(packet_header_default_sptr self) -> packet_header_default_sptr

        Params: (NONE)
        """
        return _howto_swig.packet_header_default_sptr_base(self)

    def formatter(self):
        """
        formatter(packet_header_default_sptr self) -> packet_header_default_sptr

        Params: (NONE)
        """
        return _howto_swig.packet_header_default_sptr_formatter(self)

    def set_header_num(self, *args, **kwargs):
        """
        set_header_num(packet_header_default_sptr self, unsigned int header_num)

        Params: (header_num)
        """
        return _howto_swig.packet_header_default_sptr_set_header_num(self, *args, **kwargs)

    def header_len(self):
        """
        header_len(packet_header_default_sptr self) -> long

        Params: (NONE)
        """
        return _howto_swig.packet_header_default_sptr_header_len(self)

    def len_tag_key(self):
        """
        len_tag_key(packet_header_default_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.packet_header_default_sptr_len_tag_key(self)

    def header_formatter(self, *args, **kwargs):
        """
        header_formatter(packet_header_default_sptr self, long packet_len, unsigned char * out, tags_vector_t tags=std::vector< gr::tag_t >()) -> bool

        Encodes the header information in the given tags into bits and places them into .

        Uses the following header format: Bits 0-11: The packet length (what was stored in the tag with key ) Bits 12-23: The header number (counts up everytime this function is called) Bit 24-31: 8-Bit CRC All other bits: Are set to zero

        If the header length is smaller than 32, bits are simply left out. For this reason, they always start with the LSB.

        However, it is recommended to stay above 32 Bits, in order to have a working CRC.

        Params: (packet_len, out, tags)
        """
        return _howto_swig.packet_header_default_sptr_header_formatter(self, *args, **kwargs)

    def header_parser(self, *args, **kwargs):
        """
        header_parser(packet_header_default_sptr self, unsigned char const * header, tags_vector_t tags) -> bool

        Inverse function to header_formatter().

        Reads the bit stream in  and writes a corresponding tag into .

        Params: (header, tags)
        """
        return _howto_swig.packet_header_default_sptr_header_parser(self, *args, **kwargs)

    def make(self, *args, **kwargs):
        """
        make(packet_header_default_sptr self, long header_len, std::string const & len_tag_key="packet_len", std::string const & num_tag_key="packet_num", 
            std::string const & device_id_tag_key="device_id", 
            std::string const & message_type_tag_key="message_type", int bits_per_byte=1) -> packet_header_default_sptr

        Params: (header_len, len_tag_key, num_tag_key, device_id_tag_key, message_type_tag_key, bits_per_byte)
        """
        return _howto_swig.packet_header_default_sptr_make(self, *args, **kwargs)

packet_header_default_sptr_swigregister = _howto_swig.packet_header_default_sptr_swigregister
packet_header_default_sptr_swigregister(packet_header_default_sptr)

packet_header_default_sptr.__repr__ = lambda self: "<packet_header_default>"
packet_header_default = packet_header_default.make;

class packet_header_ofdm_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::packet_header_ofdm)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::packet_header_ofdm)> self) -> packet_header_ofdm_sptr
        __init__(boost::shared_ptr<(gr::howto::packet_header_ofdm)> self, packet_header_ofdm p) -> packet_header_ofdm_sptr
        """
        this = _howto_swig.new_packet_header_ofdm_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(packet_header_ofdm_sptr self) -> packet_header_ofdm"""
        return _howto_swig.packet_header_ofdm_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_packet_header_ofdm_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(packet_header_ofdm_sptr self, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            int n_syms, std::string const & len_tag_key="packet_len", 
            std::string const & frame_len_tag_key="frame_len", 
            std::string const & num_tag_key="packet_num", std::string const & device_id_tag_key="device_id", 
            std::string const & message_type_tag_key="message_type", 
            int bits_per_header_sym=1, int bits_per_payload_sym=1, 
            bool header_split=False, bool scramble_header=False) -> packet_header_ofdm_sptr

        Params: (occupied_carriers, n_syms, len_tag_key, frame_len_tag_key, num_tag_key, device_id_tag_key, message_type_tag_key, bits_per_header_sym, bits_per_payload_sym, header_split, scramble_header)
        """
        return _howto_swig.packet_header_ofdm_sptr_make(self, *args, **kwargs)

    def base(self):
        """
        base(packet_header_ofdm_sptr self) -> packet_header_default_sptr

        Params: (NONE)
        """
        return _howto_swig.packet_header_ofdm_sptr_base(self)

    def formatter(self):
        """
        formatter(packet_header_ofdm_sptr self) -> packet_header_default_sptr

        Params: (NONE)
        """
        return _howto_swig.packet_header_ofdm_sptr_formatter(self)

    def set_header_num(self, *args, **kwargs):
        """
        set_header_num(packet_header_ofdm_sptr self, unsigned int header_num)

        Params: (header_num)
        """
        return _howto_swig.packet_header_ofdm_sptr_set_header_num(self, *args, **kwargs)

    def header_len(self):
        """
        header_len(packet_header_ofdm_sptr self) -> long

        Params: (NONE)
        """
        return _howto_swig.packet_header_ofdm_sptr_header_len(self)

    def len_tag_key(self):
        """
        len_tag_key(packet_header_ofdm_sptr self) -> swig_int_ptr

        Params: (NONE)
        """
        return _howto_swig.packet_header_ofdm_sptr_len_tag_key(self)

    def header_formatter(self, *args, **kwargs):
        """
        header_formatter(packet_header_ofdm_sptr self, long packet_len, unsigned char * out, tags_vector_t tags=std::vector< gr::tag_t >()) -> bool

        Encodes the header information in the given tags into bits and places them into .

        Uses the following header format: Bits 0-11: The packet length (what was stored in the tag with key ) Bits 12-23: The header number (counts up everytime this function is called) Bit 24-31: 8-Bit CRC All other bits: Are set to zero

        If the header length is smaller than 32, bits are simply left out. For this reason, they always start with the LSB.

        However, it is recommended to stay above 32 Bits, in order to have a working CRC.

        Params: (packet_len, out, tags)
        """
        return _howto_swig.packet_header_ofdm_sptr_header_formatter(self, *args, **kwargs)

    def header_parser(self, *args, **kwargs):
        """
        header_parser(packet_header_ofdm_sptr self, unsigned char const * header, tags_vector_t tags) -> bool

        Inverse function to header_formatter().

        Reads the bit stream in  and writes a corresponding tag into .

        Params: (header, tags)
        """
        return _howto_swig.packet_header_ofdm_sptr_header_parser(self, *args, **kwargs)

packet_header_ofdm_sptr_swigregister = _howto_swig.packet_header_ofdm_sptr_swigregister
packet_header_ofdm_sptr_swigregister(packet_header_ofdm_sptr)

packet_header_ofdm_sptr.__repr__ = lambda self: "<packet_header_ofdm>"
packet_header_ofdm = packet_header_ofdm.make;

class sc_fdma_interleaver(object):
    """<+description of block+>"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int lower_fft_len, int upper_fft_len, bool forward, gr_vector_vector_complexf sync_words, 
            std::string const & len_tag_key="packet_len") -> sc_fdma_interleaver_sptr

        Return a shared_ptr to a new instance of howto::sc_fdma_interleaver.

        To avoid accidental use of raw pointers, howto::sc_fdma_interleaver's constructor is in a private implementation class. howto::sc_fdma_interleaver::make is the public interface for creating new instances.

        Params: (lower_fft_len, upper_fft_len, forward, sync_words, len_tag_key)
        """
        return _howto_swig.sc_fdma_interleaver_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_sc_fdma_interleaver
    __del__ = lambda self : None;
sc_fdma_interleaver_swigregister = _howto_swig.sc_fdma_interleaver_swigregister
sc_fdma_interleaver_swigregister(sc_fdma_interleaver)

def sc_fdma_interleaver_make(*args, **kwargs):
  """
    sc_fdma_interleaver_make(int lower_fft_len, int upper_fft_len, bool forward, gr_vector_vector_complexf sync_words, 
        std::string const & len_tag_key="packet_len") -> sc_fdma_interleaver_sptr

    Return a shared_ptr to a new instance of howto::sc_fdma_interleaver.

    To avoid accidental use of raw pointers, howto::sc_fdma_interleaver's constructor is in a private implementation class. howto::sc_fdma_interleaver::make is the public interface for creating new instances.

    Params: (lower_fft_len, upper_fft_len, forward, sync_words, len_tag_key)
    """
  return _howto_swig.sc_fdma_interleaver_make(*args, **kwargs)

class sc_fdma_interleaver_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::sc_fdma_interleaver)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_interleaver)> self) -> sc_fdma_interleaver_sptr
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_interleaver)> self, sc_fdma_interleaver p) -> sc_fdma_interleaver_sptr
        """
        this = _howto_swig.new_sc_fdma_interleaver_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(sc_fdma_interleaver_sptr self) -> sc_fdma_interleaver"""
        return _howto_swig.sc_fdma_interleaver_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_sc_fdma_interleaver_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(sc_fdma_interleaver_sptr self, int lower_fft_len, int upper_fft_len, bool forward, gr_vector_vector_complexf sync_words, 
            std::string const & len_tag_key="packet_len") -> sc_fdma_interleaver_sptr

        Return a shared_ptr to a new instance of howto::sc_fdma_interleaver.

        To avoid accidental use of raw pointers, howto::sc_fdma_interleaver's constructor is in a private implementation class. howto::sc_fdma_interleaver::make is the public interface for creating new instances.

        Params: (lower_fft_len, upper_fft_len, forward, sync_words, len_tag_key)
        """
        return _howto_swig.sc_fdma_interleaver_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(sc_fdma_interleaver_sptr self) -> unsigned int"""
        return _howto_swig.sc_fdma_interleaver_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(sc_fdma_interleaver_sptr self, int which, int delay)
        declare_sample_delay(sc_fdma_interleaver_sptr self, unsigned int delay)
        """
        return _howto_swig.sc_fdma_interleaver_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(sc_fdma_interleaver_sptr self, int which) -> unsigned int"""
        return _howto_swig.sc_fdma_interleaver_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(sc_fdma_interleaver_sptr self) -> int"""
        return _howto_swig.sc_fdma_interleaver_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(sc_fdma_interleaver_sptr self) -> double"""
        return _howto_swig.sc_fdma_interleaver_sptr_relative_rate(self)

    def start(self):
        """start(sc_fdma_interleaver_sptr self) -> bool"""
        return _howto_swig.sc_fdma_interleaver_sptr_start(self)

    def stop(self):
        """stop(sc_fdma_interleaver_sptr self) -> bool"""
        return _howto_swig.sc_fdma_interleaver_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(sc_fdma_interleaver_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.sc_fdma_interleaver_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(sc_fdma_interleaver_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.sc_fdma_interleaver_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(sc_fdma_interleaver_sptr self) -> int"""
        return _howto_swig.sc_fdma_interleaver_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(sc_fdma_interleaver_sptr self, int m)"""
        return _howto_swig.sc_fdma_interleaver_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(sc_fdma_interleaver_sptr self)"""
        return _howto_swig.sc_fdma_interleaver_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(sc_fdma_interleaver_sptr self) -> bool"""
        return _howto_swig.sc_fdma_interleaver_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(sc_fdma_interleaver_sptr self, int m)"""
        return _howto_swig.sc_fdma_interleaver_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(sc_fdma_interleaver_sptr self) -> int"""
        return _howto_swig.sc_fdma_interleaver_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(sc_fdma_interleaver_sptr self, int i) -> long"""
        return _howto_swig.sc_fdma_interleaver_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(sc_fdma_interleaver_sptr self, long max_output_buffer)
        set_max_output_buffer(sc_fdma_interleaver_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.sc_fdma_interleaver_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(sc_fdma_interleaver_sptr self, int i) -> long"""
        return _howto_swig.sc_fdma_interleaver_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(sc_fdma_interleaver_sptr self, long min_output_buffer)
        set_min_output_buffer(sc_fdma_interleaver_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.sc_fdma_interleaver_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(sc_fdma_interleaver_sptr self) -> float"""
        return _howto_swig.sc_fdma_interleaver_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(sc_fdma_interleaver_sptr self) -> float"""
        return _howto_swig.sc_fdma_interleaver_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(sc_fdma_interleaver_sptr self) -> float"""
        return _howto_swig.sc_fdma_interleaver_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(sc_fdma_interleaver_sptr self) -> float"""
        return _howto_swig.sc_fdma_interleaver_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(sc_fdma_interleaver_sptr self) -> float"""
        return _howto_swig.sc_fdma_interleaver_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(sc_fdma_interleaver_sptr self) -> float"""
        return _howto_swig.sc_fdma_interleaver_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(sc_fdma_interleaver_sptr self, int which) -> float
        pc_input_buffers_full(sc_fdma_interleaver_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_interleaver_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(sc_fdma_interleaver_sptr self, int which) -> float
        pc_input_buffers_full_avg(sc_fdma_interleaver_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_interleaver_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(sc_fdma_interleaver_sptr self, int which) -> float
        pc_input_buffers_full_var(sc_fdma_interleaver_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_interleaver_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(sc_fdma_interleaver_sptr self, int which) -> float
        pc_output_buffers_full(sc_fdma_interleaver_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_interleaver_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(sc_fdma_interleaver_sptr self, int which) -> float
        pc_output_buffers_full_avg(sc_fdma_interleaver_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_interleaver_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(sc_fdma_interleaver_sptr self, int which) -> float
        pc_output_buffers_full_var(sc_fdma_interleaver_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_interleaver_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(sc_fdma_interleaver_sptr self) -> float"""
        return _howto_swig.sc_fdma_interleaver_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(sc_fdma_interleaver_sptr self) -> float"""
        return _howto_swig.sc_fdma_interleaver_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(sc_fdma_interleaver_sptr self) -> float"""
        return _howto_swig.sc_fdma_interleaver_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(sc_fdma_interleaver_sptr self) -> float"""
        return _howto_swig.sc_fdma_interleaver_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(sc_fdma_interleaver_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.sc_fdma_interleaver_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(sc_fdma_interleaver_sptr self)"""
        return _howto_swig.sc_fdma_interleaver_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(sc_fdma_interleaver_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.sc_fdma_interleaver_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(sc_fdma_interleaver_sptr self) -> int"""
        return _howto_swig.sc_fdma_interleaver_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(sc_fdma_interleaver_sptr self) -> int"""
        return _howto_swig.sc_fdma_interleaver_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(sc_fdma_interleaver_sptr self, int priority) -> int"""
        return _howto_swig.sc_fdma_interleaver_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(sc_fdma_interleaver_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_interleaver_sptr_name(self)

    def symbol_name(self):
        """symbol_name(sc_fdma_interleaver_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_interleaver_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(sc_fdma_interleaver_sptr self) -> io_signature_sptr"""
        return _howto_swig.sc_fdma_interleaver_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(sc_fdma_interleaver_sptr self) -> io_signature_sptr"""
        return _howto_swig.sc_fdma_interleaver_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(sc_fdma_interleaver_sptr self) -> long"""
        return _howto_swig.sc_fdma_interleaver_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(sc_fdma_interleaver_sptr self) -> basic_block_sptr"""
        return _howto_swig.sc_fdma_interleaver_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(sc_fdma_interleaver_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.sc_fdma_interleaver_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(sc_fdma_interleaver_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_interleaver_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(sc_fdma_interleaver_sptr self, std::string name)"""
        return _howto_swig.sc_fdma_interleaver_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(sc_fdma_interleaver_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.sc_fdma_interleaver_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(sc_fdma_interleaver_sptr self) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_interleaver_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(sc_fdma_interleaver_sptr self) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_interleaver_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(sc_fdma_interleaver_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_interleaver_sptr_message_subscribers(self, *args, **kwargs)

sc_fdma_interleaver_sptr_swigregister = _howto_swig.sc_fdma_interleaver_sptr_swigregister
sc_fdma_interleaver_sptr_swigregister(sc_fdma_interleaver_sptr)

sc_fdma_interleaver_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
sc_fdma_interleaver = sc_fdma_interleaver.make;

class sc_fdma_carrier_allocator_cvc(object):
    """Proxy of C++ gr::howto::sc_fdma_carrier_allocator_cvc class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def len_tag_key(self):
        """
        len_tag_key(sc_fdma_carrier_allocator_cvc self) -> std::string

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_len_tag_key(self)

    def fft_len(self):
        """
        fft_len(sc_fdma_carrier_allocator_cvc self) -> int const

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_fft_len(self)

    def occupied_carriers(self):
        """
        occupied_carriers(sc_fdma_carrier_allocator_cvc self) -> std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_occupied_carriers(self)

    def make(*args, **kwargs):
        """
        make(int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            std::string const & len_tag_key="packet_len", 
            bool const output_is_shifted=True) -> sc_fdma_carrier_allocator_cvc_sptr

        Params: (fft_len, occupied_carriers, len_tag_key, output_is_shifted)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_sc_fdma_carrier_allocator_cvc
    __del__ = lambda self : None;
sc_fdma_carrier_allocator_cvc_swigregister = _howto_swig.sc_fdma_carrier_allocator_cvc_swigregister
sc_fdma_carrier_allocator_cvc_swigregister(sc_fdma_carrier_allocator_cvc)

def sc_fdma_carrier_allocator_cvc_make(*args, **kwargs):
  """
    sc_fdma_carrier_allocator_cvc_make(int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
        std::string const & len_tag_key="packet_len", 
        bool const output_is_shifted=True) -> sc_fdma_carrier_allocator_cvc_sptr

    Params: (fft_len, occupied_carriers, len_tag_key, output_is_shifted)
    """
  return _howto_swig.sc_fdma_carrier_allocator_cvc_make(*args, **kwargs)

class sc_fdma_carrier_allocator_cvc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::sc_fdma_carrier_allocator_cvc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_carrier_allocator_cvc)> self) -> sc_fdma_carrier_allocator_cvc_sptr
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_carrier_allocator_cvc)> self, sc_fdma_carrier_allocator_cvc p) -> sc_fdma_carrier_allocator_cvc_sptr
        """
        this = _howto_swig.new_sc_fdma_carrier_allocator_cvc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(sc_fdma_carrier_allocator_cvc_sptr self) -> sc_fdma_carrier_allocator_cvc"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_sc_fdma_carrier_allocator_cvc_sptr
    __del__ = lambda self : None;
    def len_tag_key(self):
        """
        len_tag_key(sc_fdma_carrier_allocator_cvc_sptr self) -> std::string

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_len_tag_key(self)

    def fft_len(self):
        """
        fft_len(sc_fdma_carrier_allocator_cvc_sptr self) -> int const

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_fft_len(self)

    def occupied_carriers(self):
        """
        occupied_carriers(sc_fdma_carrier_allocator_cvc_sptr self) -> std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >

        Params: (NONE)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_occupied_carriers(self)

    def make(self, *args, **kwargs):
        """
        make(sc_fdma_carrier_allocator_cvc_sptr self, int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            std::string const & len_tag_key="packet_len", 
            bool const output_is_shifted=True) -> sc_fdma_carrier_allocator_cvc_sptr

        Params: (fft_len, occupied_carriers, len_tag_key, output_is_shifted)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(sc_fdma_carrier_allocator_cvc_sptr self) -> unsigned int"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(sc_fdma_carrier_allocator_cvc_sptr self, int which, int delay)
        declare_sample_delay(sc_fdma_carrier_allocator_cvc_sptr self, unsigned int delay)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(sc_fdma_carrier_allocator_cvc_sptr self, int which) -> unsigned int"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(sc_fdma_carrier_allocator_cvc_sptr self) -> int"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(sc_fdma_carrier_allocator_cvc_sptr self) -> double"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_relative_rate(self)

    def start(self):
        """start(sc_fdma_carrier_allocator_cvc_sptr self) -> bool"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_start(self)

    def stop(self):
        """stop(sc_fdma_carrier_allocator_cvc_sptr self) -> bool"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(sc_fdma_carrier_allocator_cvc_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(sc_fdma_carrier_allocator_cvc_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(sc_fdma_carrier_allocator_cvc_sptr self) -> int"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(sc_fdma_carrier_allocator_cvc_sptr self, int m)"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(sc_fdma_carrier_allocator_cvc_sptr self)"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(sc_fdma_carrier_allocator_cvc_sptr self) -> bool"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(sc_fdma_carrier_allocator_cvc_sptr self, int m)"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(sc_fdma_carrier_allocator_cvc_sptr self) -> int"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(sc_fdma_carrier_allocator_cvc_sptr self, int i) -> long"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(sc_fdma_carrier_allocator_cvc_sptr self, long max_output_buffer)
        set_max_output_buffer(sc_fdma_carrier_allocator_cvc_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(sc_fdma_carrier_allocator_cvc_sptr self, int i) -> long"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(sc_fdma_carrier_allocator_cvc_sptr self, long min_output_buffer)
        set_min_output_buffer(sc_fdma_carrier_allocator_cvc_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(sc_fdma_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(sc_fdma_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(sc_fdma_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(sc_fdma_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(sc_fdma_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(sc_fdma_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(sc_fdma_carrier_allocator_cvc_sptr self, int which) -> float
        pc_input_buffers_full(sc_fdma_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(sc_fdma_carrier_allocator_cvc_sptr self, int which) -> float
        pc_input_buffers_full_avg(sc_fdma_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(sc_fdma_carrier_allocator_cvc_sptr self, int which) -> float
        pc_input_buffers_full_var(sc_fdma_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(sc_fdma_carrier_allocator_cvc_sptr self, int which) -> float
        pc_output_buffers_full(sc_fdma_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(sc_fdma_carrier_allocator_cvc_sptr self, int which) -> float
        pc_output_buffers_full_avg(sc_fdma_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(sc_fdma_carrier_allocator_cvc_sptr self, int which) -> float
        pc_output_buffers_full_var(sc_fdma_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(sc_fdma_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(sc_fdma_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(sc_fdma_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(sc_fdma_carrier_allocator_cvc_sptr self) -> float"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(sc_fdma_carrier_allocator_cvc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(sc_fdma_carrier_allocator_cvc_sptr self)"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(sc_fdma_carrier_allocator_cvc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(sc_fdma_carrier_allocator_cvc_sptr self) -> int"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(sc_fdma_carrier_allocator_cvc_sptr self) -> int"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(sc_fdma_carrier_allocator_cvc_sptr self, int priority) -> int"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(sc_fdma_carrier_allocator_cvc_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(sc_fdma_carrier_allocator_cvc_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(sc_fdma_carrier_allocator_cvc_sptr self) -> io_signature_sptr"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(sc_fdma_carrier_allocator_cvc_sptr self) -> io_signature_sptr"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(sc_fdma_carrier_allocator_cvc_sptr self) -> long"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(sc_fdma_carrier_allocator_cvc_sptr self) -> basic_block_sptr"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(sc_fdma_carrier_allocator_cvc_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(sc_fdma_carrier_allocator_cvc_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(sc_fdma_carrier_allocator_cvc_sptr self, std::string name)"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(sc_fdma_carrier_allocator_cvc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(sc_fdma_carrier_allocator_cvc_sptr self) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(sc_fdma_carrier_allocator_cvc_sptr self) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(sc_fdma_carrier_allocator_cvc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_message_subscribers(self, *args, **kwargs)

sc_fdma_carrier_allocator_cvc_sptr_swigregister = _howto_swig.sc_fdma_carrier_allocator_cvc_sptr_swigregister
sc_fdma_carrier_allocator_cvc_sptr_swigregister(sc_fdma_carrier_allocator_cvc_sptr)

sc_fdma_carrier_allocator_cvc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
sc_fdma_carrier_allocator_cvc = sc_fdma_carrier_allocator_cvc.make;

class symbol_decision(object):
    """<+description of block+>"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int fft_len, constellation_sptr constellation, std::string const & len_tag_key="frame_len") -> symbol_decision_sptr

        Return a shared_ptr to a new instance of howto::symbol_decision.

        To avoid accidental use of raw pointers, howto::symbol_decision's constructor is in a private implementation class. howto::symbol_decision::make is the public interface for creating new instances.

        Params: (fft_len, constellation, len_tag_key)
        """
        return _howto_swig.symbol_decision_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_symbol_decision
    __del__ = lambda self : None;
symbol_decision_swigregister = _howto_swig.symbol_decision_swigregister
symbol_decision_swigregister(symbol_decision)

def symbol_decision_make(*args, **kwargs):
  """
    symbol_decision_make(int fft_len, constellation_sptr constellation, std::string const & len_tag_key="frame_len") -> symbol_decision_sptr

    Return a shared_ptr to a new instance of howto::symbol_decision.

    To avoid accidental use of raw pointers, howto::symbol_decision's constructor is in a private implementation class. howto::symbol_decision::make is the public interface for creating new instances.

    Params: (fft_len, constellation, len_tag_key)
    """
  return _howto_swig.symbol_decision_make(*args, **kwargs)

class symbol_decision_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::symbol_decision)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::symbol_decision)> self) -> symbol_decision_sptr
        __init__(boost::shared_ptr<(gr::howto::symbol_decision)> self, symbol_decision p) -> symbol_decision_sptr
        """
        this = _howto_swig.new_symbol_decision_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(symbol_decision_sptr self) -> symbol_decision"""
        return _howto_swig.symbol_decision_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_symbol_decision_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(symbol_decision_sptr self, int fft_len, constellation_sptr constellation, std::string const & len_tag_key="frame_len") -> symbol_decision_sptr

        Return a shared_ptr to a new instance of howto::symbol_decision.

        To avoid accidental use of raw pointers, howto::symbol_decision's constructor is in a private implementation class. howto::symbol_decision::make is the public interface for creating new instances.

        Params: (fft_len, constellation, len_tag_key)
        """
        return _howto_swig.symbol_decision_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(symbol_decision_sptr self) -> unsigned int"""
        return _howto_swig.symbol_decision_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(symbol_decision_sptr self, int which, int delay)
        declare_sample_delay(symbol_decision_sptr self, unsigned int delay)
        """
        return _howto_swig.symbol_decision_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(symbol_decision_sptr self, int which) -> unsigned int"""
        return _howto_swig.symbol_decision_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(symbol_decision_sptr self) -> int"""
        return _howto_swig.symbol_decision_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(symbol_decision_sptr self) -> double"""
        return _howto_swig.symbol_decision_sptr_relative_rate(self)

    def start(self):
        """start(symbol_decision_sptr self) -> bool"""
        return _howto_swig.symbol_decision_sptr_start(self)

    def stop(self):
        """stop(symbol_decision_sptr self) -> bool"""
        return _howto_swig.symbol_decision_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(symbol_decision_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.symbol_decision_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(symbol_decision_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.symbol_decision_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(symbol_decision_sptr self) -> int"""
        return _howto_swig.symbol_decision_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(symbol_decision_sptr self, int m)"""
        return _howto_swig.symbol_decision_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(symbol_decision_sptr self)"""
        return _howto_swig.symbol_decision_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(symbol_decision_sptr self) -> bool"""
        return _howto_swig.symbol_decision_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(symbol_decision_sptr self, int m)"""
        return _howto_swig.symbol_decision_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(symbol_decision_sptr self) -> int"""
        return _howto_swig.symbol_decision_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(symbol_decision_sptr self, int i) -> long"""
        return _howto_swig.symbol_decision_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(symbol_decision_sptr self, long max_output_buffer)
        set_max_output_buffer(symbol_decision_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.symbol_decision_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(symbol_decision_sptr self, int i) -> long"""
        return _howto_swig.symbol_decision_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(symbol_decision_sptr self, long min_output_buffer)
        set_min_output_buffer(symbol_decision_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.symbol_decision_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(symbol_decision_sptr self) -> float"""
        return _howto_swig.symbol_decision_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(symbol_decision_sptr self) -> float"""
        return _howto_swig.symbol_decision_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(symbol_decision_sptr self) -> float"""
        return _howto_swig.symbol_decision_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(symbol_decision_sptr self) -> float"""
        return _howto_swig.symbol_decision_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(symbol_decision_sptr self) -> float"""
        return _howto_swig.symbol_decision_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(symbol_decision_sptr self) -> float"""
        return _howto_swig.symbol_decision_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(symbol_decision_sptr self, int which) -> float
        pc_input_buffers_full(symbol_decision_sptr self) -> pmt_vector_float
        """
        return _howto_swig.symbol_decision_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(symbol_decision_sptr self, int which) -> float
        pc_input_buffers_full_avg(symbol_decision_sptr self) -> pmt_vector_float
        """
        return _howto_swig.symbol_decision_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(symbol_decision_sptr self, int which) -> float
        pc_input_buffers_full_var(symbol_decision_sptr self) -> pmt_vector_float
        """
        return _howto_swig.symbol_decision_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(symbol_decision_sptr self, int which) -> float
        pc_output_buffers_full(symbol_decision_sptr self) -> pmt_vector_float
        """
        return _howto_swig.symbol_decision_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(symbol_decision_sptr self, int which) -> float
        pc_output_buffers_full_avg(symbol_decision_sptr self) -> pmt_vector_float
        """
        return _howto_swig.symbol_decision_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(symbol_decision_sptr self, int which) -> float
        pc_output_buffers_full_var(symbol_decision_sptr self) -> pmt_vector_float
        """
        return _howto_swig.symbol_decision_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(symbol_decision_sptr self) -> float"""
        return _howto_swig.symbol_decision_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(symbol_decision_sptr self) -> float"""
        return _howto_swig.symbol_decision_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(symbol_decision_sptr self) -> float"""
        return _howto_swig.symbol_decision_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(symbol_decision_sptr self) -> float"""
        return _howto_swig.symbol_decision_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(symbol_decision_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.symbol_decision_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(symbol_decision_sptr self)"""
        return _howto_swig.symbol_decision_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(symbol_decision_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.symbol_decision_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(symbol_decision_sptr self) -> int"""
        return _howto_swig.symbol_decision_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(symbol_decision_sptr self) -> int"""
        return _howto_swig.symbol_decision_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(symbol_decision_sptr self, int priority) -> int"""
        return _howto_swig.symbol_decision_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(symbol_decision_sptr self) -> std::string"""
        return _howto_swig.symbol_decision_sptr_name(self)

    def symbol_name(self):
        """symbol_name(symbol_decision_sptr self) -> std::string"""
        return _howto_swig.symbol_decision_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(symbol_decision_sptr self) -> io_signature_sptr"""
        return _howto_swig.symbol_decision_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(symbol_decision_sptr self) -> io_signature_sptr"""
        return _howto_swig.symbol_decision_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(symbol_decision_sptr self) -> long"""
        return _howto_swig.symbol_decision_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(symbol_decision_sptr self) -> basic_block_sptr"""
        return _howto_swig.symbol_decision_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(symbol_decision_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.symbol_decision_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(symbol_decision_sptr self) -> std::string"""
        return _howto_swig.symbol_decision_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(symbol_decision_sptr self, std::string name)"""
        return _howto_swig.symbol_decision_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(symbol_decision_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.symbol_decision_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(symbol_decision_sptr self) -> swig_int_ptr"""
        return _howto_swig.symbol_decision_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(symbol_decision_sptr self) -> swig_int_ptr"""
        return _howto_swig.symbol_decision_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(symbol_decision_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.symbol_decision_sptr_message_subscribers(self, *args, **kwargs)

symbol_decision_sptr_swigregister = _howto_swig.symbol_decision_sptr_swigregister
symbol_decision_sptr_swigregister(symbol_decision_sptr)

symbol_decision_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
symbol_decision = symbol_decision.make;

class sc_fdma_packet_headerparser_b(object):
    """<+description of block+>"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args):
        """
        make(packet_header_default_sptr header_formatter) -> sc_fdma_packet_headerparser_b_sptr
        make(long header_len, std::string const & len_tag_key) -> sc_fdma_packet_headerparser_b_sptr

        Params: (header_formatter)
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_make(*args)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_sc_fdma_packet_headerparser_b
    __del__ = lambda self : None;
sc_fdma_packet_headerparser_b_swigregister = _howto_swig.sc_fdma_packet_headerparser_b_swigregister
sc_fdma_packet_headerparser_b_swigregister(sc_fdma_packet_headerparser_b)

def sc_fdma_packet_headerparser_b_make(*args):
  """
    make(packet_header_default_sptr header_formatter) -> sc_fdma_packet_headerparser_b_sptr
    sc_fdma_packet_headerparser_b_make(long header_len, std::string const & len_tag_key) -> sc_fdma_packet_headerparser_b_sptr

    Params: (header_formatter)
    """
  return _howto_swig.sc_fdma_packet_headerparser_b_make(*args)

class sc_fdma_packet_headerparser_b_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::sc_fdma_packet_headerparser_b)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_packet_headerparser_b)> self) -> sc_fdma_packet_headerparser_b_sptr
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_packet_headerparser_b)> self, sc_fdma_packet_headerparser_b p) -> sc_fdma_packet_headerparser_b_sptr
        """
        this = _howto_swig.new_sc_fdma_packet_headerparser_b_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(sc_fdma_packet_headerparser_b_sptr self) -> sc_fdma_packet_headerparser_b"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_sc_fdma_packet_headerparser_b_sptr
    __del__ = lambda self : None;
    def make(self, *args):
        """
        make(sc_fdma_packet_headerparser_b_sptr self, packet_header_default_sptr header_formatter) -> sc_fdma_packet_headerparser_b_sptr
        make(sc_fdma_packet_headerparser_b_sptr self, long header_len, std::string const & len_tag_key) -> sc_fdma_packet_headerparser_b_sptr

        Params: (header_formatter)
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_make(self, *args)

    def history(self):
        """history(sc_fdma_packet_headerparser_b_sptr self) -> unsigned int"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(sc_fdma_packet_headerparser_b_sptr self, int which, int delay)
        declare_sample_delay(sc_fdma_packet_headerparser_b_sptr self, unsigned int delay)
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(sc_fdma_packet_headerparser_b_sptr self, int which) -> unsigned int"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(sc_fdma_packet_headerparser_b_sptr self) -> int"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(sc_fdma_packet_headerparser_b_sptr self) -> double"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_relative_rate(self)

    def start(self):
        """start(sc_fdma_packet_headerparser_b_sptr self) -> bool"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_start(self)

    def stop(self):
        """stop(sc_fdma_packet_headerparser_b_sptr self) -> bool"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(sc_fdma_packet_headerparser_b_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(sc_fdma_packet_headerparser_b_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(sc_fdma_packet_headerparser_b_sptr self) -> int"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(sc_fdma_packet_headerparser_b_sptr self, int m)"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(sc_fdma_packet_headerparser_b_sptr self)"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(sc_fdma_packet_headerparser_b_sptr self) -> bool"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(sc_fdma_packet_headerparser_b_sptr self, int m)"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(sc_fdma_packet_headerparser_b_sptr self) -> int"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(sc_fdma_packet_headerparser_b_sptr self, int i) -> long"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(sc_fdma_packet_headerparser_b_sptr self, long max_output_buffer)
        set_max_output_buffer(sc_fdma_packet_headerparser_b_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(sc_fdma_packet_headerparser_b_sptr self, int i) -> long"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(sc_fdma_packet_headerparser_b_sptr self, long min_output_buffer)
        set_min_output_buffer(sc_fdma_packet_headerparser_b_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(sc_fdma_packet_headerparser_b_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(sc_fdma_packet_headerparser_b_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(sc_fdma_packet_headerparser_b_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(sc_fdma_packet_headerparser_b_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(sc_fdma_packet_headerparser_b_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(sc_fdma_packet_headerparser_b_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(sc_fdma_packet_headerparser_b_sptr self, int which) -> float
        pc_input_buffers_full(sc_fdma_packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(sc_fdma_packet_headerparser_b_sptr self, int which) -> float
        pc_input_buffers_full_avg(sc_fdma_packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(sc_fdma_packet_headerparser_b_sptr self, int which) -> float
        pc_input_buffers_full_var(sc_fdma_packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(sc_fdma_packet_headerparser_b_sptr self, int which) -> float
        pc_output_buffers_full(sc_fdma_packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(sc_fdma_packet_headerparser_b_sptr self, int which) -> float
        pc_output_buffers_full_avg(sc_fdma_packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(sc_fdma_packet_headerparser_b_sptr self, int which) -> float
        pc_output_buffers_full_var(sc_fdma_packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(sc_fdma_packet_headerparser_b_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(sc_fdma_packet_headerparser_b_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(sc_fdma_packet_headerparser_b_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(sc_fdma_packet_headerparser_b_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(sc_fdma_packet_headerparser_b_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(sc_fdma_packet_headerparser_b_sptr self)"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(sc_fdma_packet_headerparser_b_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(sc_fdma_packet_headerparser_b_sptr self) -> int"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(sc_fdma_packet_headerparser_b_sptr self) -> int"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(sc_fdma_packet_headerparser_b_sptr self, int priority) -> int"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(sc_fdma_packet_headerparser_b_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_name(self)

    def symbol_name(self):
        """symbol_name(sc_fdma_packet_headerparser_b_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(sc_fdma_packet_headerparser_b_sptr self) -> io_signature_sptr"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(sc_fdma_packet_headerparser_b_sptr self) -> io_signature_sptr"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(sc_fdma_packet_headerparser_b_sptr self) -> long"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(sc_fdma_packet_headerparser_b_sptr self) -> basic_block_sptr"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(sc_fdma_packet_headerparser_b_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(sc_fdma_packet_headerparser_b_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(sc_fdma_packet_headerparser_b_sptr self, std::string name)"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(sc_fdma_packet_headerparser_b_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(sc_fdma_packet_headerparser_b_sptr self) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(sc_fdma_packet_headerparser_b_sptr self) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(sc_fdma_packet_headerparser_b_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_packet_headerparser_b_sptr_message_subscribers(self, *args, **kwargs)

sc_fdma_packet_headerparser_b_sptr_swigregister = _howto_swig.sc_fdma_packet_headerparser_b_sptr_swigregister
sc_fdma_packet_headerparser_b_sptr_swigregister(sc_fdma_packet_headerparser_b_sptr)

sc_fdma_packet_headerparser_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
sc_fdma_packet_headerparser_b = sc_fdma_packet_headerparser_b.make;

class sc_fdma_packet_headergenerator_bb(object):
    """
    Generates a header for a tagged, streamed packet.

    Input: A tagged stream. This is consumed entirely, it is not appended to the output stream. Output: An tagged stream containing the header. The details on the header are set in a header formatter object (of type packet_header_default or a subclass thereof). If only a number of bits is specified, a default header is generated (see packet_header_default).
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args):
        """
        make(packet_header_default_sptr header_formatter, std::string const & len_tag_key="packet_len") -> sc_fdma_packet_headergenerator_bb_sptr
        make(long header_len, std::string const & len_tag_key="packet_len") -> sc_fdma_packet_headergenerator_bb_sptr

        Params: (header_formatter, len_tag_key)
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_make(*args)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_sc_fdma_packet_headergenerator_bb
    __del__ = lambda self : None;
sc_fdma_packet_headergenerator_bb_swigregister = _howto_swig.sc_fdma_packet_headergenerator_bb_swigregister
sc_fdma_packet_headergenerator_bb_swigregister(sc_fdma_packet_headergenerator_bb)

def sc_fdma_packet_headergenerator_bb_make(*args):
  """
    make(packet_header_default_sptr header_formatter, std::string const & len_tag_key="packet_len") -> sc_fdma_packet_headergenerator_bb_sptr
    sc_fdma_packet_headergenerator_bb_make(long header_len, std::string const & len_tag_key="packet_len") -> sc_fdma_packet_headergenerator_bb_sptr

    Params: (header_formatter, len_tag_key)
    """
  return _howto_swig.sc_fdma_packet_headergenerator_bb_make(*args)

class sc_fdma_packet_headergenerator_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::sc_fdma_packet_headergenerator_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_packet_headergenerator_bb)> self) -> sc_fdma_packet_headergenerator_bb_sptr
        __init__(boost::shared_ptr<(gr::howto::sc_fdma_packet_headergenerator_bb)> self, sc_fdma_packet_headergenerator_bb p) -> sc_fdma_packet_headergenerator_bb_sptr
        """
        this = _howto_swig.new_sc_fdma_packet_headergenerator_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(sc_fdma_packet_headergenerator_bb_sptr self) -> sc_fdma_packet_headergenerator_bb"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_sc_fdma_packet_headergenerator_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args):
        """
        make(sc_fdma_packet_headergenerator_bb_sptr self, packet_header_default_sptr header_formatter, std::string const & len_tag_key="packet_len") -> sc_fdma_packet_headergenerator_bb_sptr
        make(sc_fdma_packet_headergenerator_bb_sptr self, long header_len, std::string const & len_tag_key="packet_len") -> sc_fdma_packet_headergenerator_bb_sptr

        Params: (header_formatter, len_tag_key)
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_make(self, *args)

    def history(self):
        """history(sc_fdma_packet_headergenerator_bb_sptr self) -> unsigned int"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(sc_fdma_packet_headergenerator_bb_sptr self, int which, int delay)
        declare_sample_delay(sc_fdma_packet_headergenerator_bb_sptr self, unsigned int delay)
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(sc_fdma_packet_headergenerator_bb_sptr self, int which) -> unsigned int"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(sc_fdma_packet_headergenerator_bb_sptr self) -> int"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(sc_fdma_packet_headergenerator_bb_sptr self) -> double"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_relative_rate(self)

    def start(self):
        """start(sc_fdma_packet_headergenerator_bb_sptr self) -> bool"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_start(self)

    def stop(self):
        """stop(sc_fdma_packet_headergenerator_bb_sptr self) -> bool"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(sc_fdma_packet_headergenerator_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(sc_fdma_packet_headergenerator_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(sc_fdma_packet_headergenerator_bb_sptr self) -> int"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(sc_fdma_packet_headergenerator_bb_sptr self, int m)"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(sc_fdma_packet_headergenerator_bb_sptr self)"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(sc_fdma_packet_headergenerator_bb_sptr self) -> bool"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(sc_fdma_packet_headergenerator_bb_sptr self, int m)"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(sc_fdma_packet_headergenerator_bb_sptr self) -> int"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(sc_fdma_packet_headergenerator_bb_sptr self, int i) -> long"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(sc_fdma_packet_headergenerator_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(sc_fdma_packet_headergenerator_bb_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(sc_fdma_packet_headergenerator_bb_sptr self, int i) -> long"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(sc_fdma_packet_headergenerator_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(sc_fdma_packet_headergenerator_bb_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(sc_fdma_packet_headergenerator_bb_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(sc_fdma_packet_headergenerator_bb_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(sc_fdma_packet_headergenerator_bb_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(sc_fdma_packet_headergenerator_bb_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(sc_fdma_packet_headergenerator_bb_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(sc_fdma_packet_headergenerator_bb_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(sc_fdma_packet_headergenerator_bb_sptr self, int which) -> float
        pc_input_buffers_full(sc_fdma_packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(sc_fdma_packet_headergenerator_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(sc_fdma_packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(sc_fdma_packet_headergenerator_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(sc_fdma_packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(sc_fdma_packet_headergenerator_bb_sptr self, int which) -> float
        pc_output_buffers_full(sc_fdma_packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(sc_fdma_packet_headergenerator_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(sc_fdma_packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(sc_fdma_packet_headergenerator_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(sc_fdma_packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(sc_fdma_packet_headergenerator_bb_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(sc_fdma_packet_headergenerator_bb_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(sc_fdma_packet_headergenerator_bb_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(sc_fdma_packet_headergenerator_bb_sptr self) -> float"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(sc_fdma_packet_headergenerator_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(sc_fdma_packet_headergenerator_bb_sptr self)"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(sc_fdma_packet_headergenerator_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(sc_fdma_packet_headergenerator_bb_sptr self) -> int"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(sc_fdma_packet_headergenerator_bb_sptr self) -> int"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(sc_fdma_packet_headergenerator_bb_sptr self, int priority) -> int"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(sc_fdma_packet_headergenerator_bb_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(sc_fdma_packet_headergenerator_bb_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(sc_fdma_packet_headergenerator_bb_sptr self) -> io_signature_sptr"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(sc_fdma_packet_headergenerator_bb_sptr self) -> io_signature_sptr"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(sc_fdma_packet_headergenerator_bb_sptr self) -> long"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(sc_fdma_packet_headergenerator_bb_sptr self) -> basic_block_sptr"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(sc_fdma_packet_headergenerator_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(sc_fdma_packet_headergenerator_bb_sptr self) -> std::string"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(sc_fdma_packet_headergenerator_bb_sptr self, std::string name)"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(sc_fdma_packet_headergenerator_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(sc_fdma_packet_headergenerator_bb_sptr self) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(sc_fdma_packet_headergenerator_bb_sptr self) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(sc_fdma_packet_headergenerator_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_message_subscribers(self, *args, **kwargs)

sc_fdma_packet_headergenerator_bb_sptr_swigregister = _howto_swig.sc_fdma_packet_headergenerator_bb_sptr_swigregister
sc_fdma_packet_headergenerator_bb_sptr_swigregister(sc_fdma_packet_headergenerator_bb_sptr)

sc_fdma_packet_headergenerator_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
sc_fdma_packet_headergenerator_bb = sc_fdma_packet_headergenerator_bb.make;

class base_station_core(object):
    """<+description of block+>"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< unsigned char,std::allocator< unsigned char > > const & data, unsigned int const packet_len, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & request_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_utb) -> base_station_core_sptr

        Return a shared_ptr to a new instance of howto::base_station_core.

        To avoid accidental use of raw pointers, howto::base_station_core's constructor is in a private implementation class. howto::base_station_core::make is the public interface for creating new instances.

        Params: (data, packet_len, request_utb, acknowledgement_btu, acknowledgement_utb, acknowledgement_end_btu, acknowledgement_end_utb)
        """
        return _howto_swig.base_station_core_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_base_station_core
    __del__ = lambda self : None;
base_station_core_swigregister = _howto_swig.base_station_core_swigregister
base_station_core_swigregister(base_station_core)

def base_station_core_make(*args, **kwargs):
  """
    base_station_core_make(std::vector< unsigned char,std::allocator< unsigned char > > const & data, unsigned int const packet_len, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & request_utb, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_btu, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_utb, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_btu, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_utb) -> base_station_core_sptr

    Return a shared_ptr to a new instance of howto::base_station_core.

    To avoid accidental use of raw pointers, howto::base_station_core's constructor is in a private implementation class. howto::base_station_core::make is the public interface for creating new instances.

    Params: (data, packet_len, request_utb, acknowledgement_btu, acknowledgement_utb, acknowledgement_end_btu, acknowledgement_end_utb)
    """
  return _howto_swig.base_station_core_make(*args, **kwargs)

class base_station_core_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::base_station_core)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::base_station_core)> self) -> base_station_core_sptr
        __init__(boost::shared_ptr<(gr::howto::base_station_core)> self, base_station_core p) -> base_station_core_sptr
        """
        this = _howto_swig.new_base_station_core_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(base_station_core_sptr self) -> base_station_core"""
        return _howto_swig.base_station_core_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_base_station_core_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(base_station_core_sptr self, std::vector< unsigned char,std::allocator< unsigned char > > const & data, unsigned int const packet_len, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & request_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_utb) -> base_station_core_sptr

        Return a shared_ptr to a new instance of howto::base_station_core.

        To avoid accidental use of raw pointers, howto::base_station_core's constructor is in a private implementation class. howto::base_station_core::make is the public interface for creating new instances.

        Params: (data, packet_len, request_utb, acknowledgement_btu, acknowledgement_utb, acknowledgement_end_btu, acknowledgement_end_utb)
        """
        return _howto_swig.base_station_core_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(base_station_core_sptr self) -> unsigned int"""
        return _howto_swig.base_station_core_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(base_station_core_sptr self, int which, int delay)
        declare_sample_delay(base_station_core_sptr self, unsigned int delay)
        """
        return _howto_swig.base_station_core_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(base_station_core_sptr self, int which) -> unsigned int"""
        return _howto_swig.base_station_core_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(base_station_core_sptr self) -> int"""
        return _howto_swig.base_station_core_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(base_station_core_sptr self) -> double"""
        return _howto_swig.base_station_core_sptr_relative_rate(self)

    def start(self):
        """start(base_station_core_sptr self) -> bool"""
        return _howto_swig.base_station_core_sptr_start(self)

    def stop(self):
        """stop(base_station_core_sptr self) -> bool"""
        return _howto_swig.base_station_core_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(base_station_core_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.base_station_core_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(base_station_core_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.base_station_core_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(base_station_core_sptr self) -> int"""
        return _howto_swig.base_station_core_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(base_station_core_sptr self, int m)"""
        return _howto_swig.base_station_core_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(base_station_core_sptr self)"""
        return _howto_swig.base_station_core_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(base_station_core_sptr self) -> bool"""
        return _howto_swig.base_station_core_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(base_station_core_sptr self, int m)"""
        return _howto_swig.base_station_core_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(base_station_core_sptr self) -> int"""
        return _howto_swig.base_station_core_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(base_station_core_sptr self, int i) -> long"""
        return _howto_swig.base_station_core_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(base_station_core_sptr self, long max_output_buffer)
        set_max_output_buffer(base_station_core_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.base_station_core_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(base_station_core_sptr self, int i) -> long"""
        return _howto_swig.base_station_core_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(base_station_core_sptr self, long min_output_buffer)
        set_min_output_buffer(base_station_core_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.base_station_core_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(base_station_core_sptr self) -> float"""
        return _howto_swig.base_station_core_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(base_station_core_sptr self) -> float"""
        return _howto_swig.base_station_core_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(base_station_core_sptr self) -> float"""
        return _howto_swig.base_station_core_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(base_station_core_sptr self) -> float"""
        return _howto_swig.base_station_core_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(base_station_core_sptr self) -> float"""
        return _howto_swig.base_station_core_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(base_station_core_sptr self) -> float"""
        return _howto_swig.base_station_core_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(base_station_core_sptr self, int which) -> float
        pc_input_buffers_full(base_station_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.base_station_core_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(base_station_core_sptr self, int which) -> float
        pc_input_buffers_full_avg(base_station_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.base_station_core_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(base_station_core_sptr self, int which) -> float
        pc_input_buffers_full_var(base_station_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.base_station_core_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(base_station_core_sptr self, int which) -> float
        pc_output_buffers_full(base_station_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.base_station_core_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(base_station_core_sptr self, int which) -> float
        pc_output_buffers_full_avg(base_station_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.base_station_core_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(base_station_core_sptr self, int which) -> float
        pc_output_buffers_full_var(base_station_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.base_station_core_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(base_station_core_sptr self) -> float"""
        return _howto_swig.base_station_core_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(base_station_core_sptr self) -> float"""
        return _howto_swig.base_station_core_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(base_station_core_sptr self) -> float"""
        return _howto_swig.base_station_core_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(base_station_core_sptr self) -> float"""
        return _howto_swig.base_station_core_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(base_station_core_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.base_station_core_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(base_station_core_sptr self)"""
        return _howto_swig.base_station_core_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(base_station_core_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.base_station_core_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(base_station_core_sptr self) -> int"""
        return _howto_swig.base_station_core_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(base_station_core_sptr self) -> int"""
        return _howto_swig.base_station_core_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(base_station_core_sptr self, int priority) -> int"""
        return _howto_swig.base_station_core_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(base_station_core_sptr self) -> std::string"""
        return _howto_swig.base_station_core_sptr_name(self)

    def symbol_name(self):
        """symbol_name(base_station_core_sptr self) -> std::string"""
        return _howto_swig.base_station_core_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(base_station_core_sptr self) -> io_signature_sptr"""
        return _howto_swig.base_station_core_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(base_station_core_sptr self) -> io_signature_sptr"""
        return _howto_swig.base_station_core_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(base_station_core_sptr self) -> long"""
        return _howto_swig.base_station_core_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(base_station_core_sptr self) -> basic_block_sptr"""
        return _howto_swig.base_station_core_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(base_station_core_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.base_station_core_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(base_station_core_sptr self) -> std::string"""
        return _howto_swig.base_station_core_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(base_station_core_sptr self, std::string name)"""
        return _howto_swig.base_station_core_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(base_station_core_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.base_station_core_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(base_station_core_sptr self) -> swig_int_ptr"""
        return _howto_swig.base_station_core_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(base_station_core_sptr self) -> swig_int_ptr"""
        return _howto_swig.base_station_core_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(base_station_core_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.base_station_core_sptr_message_subscribers(self, *args, **kwargs)

base_station_core_sptr_swigregister = _howto_swig.base_station_core_sptr_swigregister
base_station_core_sptr_swigregister(base_station_core_sptr)

base_station_core_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
base_station_core = base_station_core.make;

class user_device_core(object):
    """<+description of block+>"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int const device_id, unsigned int const packet_len, std::vector< unsigned char,std::allocator< unsigned char > > const & request_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_utb) -> user_device_core_sptr

        Return a shared_ptr to a new instance of howto::user_device_core.

        To avoid accidental use of raw pointers, howto::user_device_core's constructor is in a private implementation class. howto::user_device_core::make is the public interface for creating new instances.

        Params: (device_id, packet_len, request_utb, acknowledgement_btu, acknowledgement_utb, acknowledgement_end_btu, acknowledgement_end_utb)
        """
        return _howto_swig.user_device_core_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_user_device_core
    __del__ = lambda self : None;
user_device_core_swigregister = _howto_swig.user_device_core_swigregister
user_device_core_swigregister(user_device_core)

def user_device_core_make(*args, **kwargs):
  """
    user_device_core_make(unsigned int const device_id, unsigned int const packet_len, std::vector< unsigned char,std::allocator< unsigned char > > const & request_utb, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_btu, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_utb, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_btu, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_utb) -> user_device_core_sptr

    Return a shared_ptr to a new instance of howto::user_device_core.

    To avoid accidental use of raw pointers, howto::user_device_core's constructor is in a private implementation class. howto::user_device_core::make is the public interface for creating new instances.

    Params: (device_id, packet_len, request_utb, acknowledgement_btu, acknowledgement_utb, acknowledgement_end_btu, acknowledgement_end_utb)
    """
  return _howto_swig.user_device_core_make(*args, **kwargs)

class user_device_core_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::user_device_core)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::user_device_core)> self) -> user_device_core_sptr
        __init__(boost::shared_ptr<(gr::howto::user_device_core)> self, user_device_core p) -> user_device_core_sptr
        """
        this = _howto_swig.new_user_device_core_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(user_device_core_sptr self) -> user_device_core"""
        return _howto_swig.user_device_core_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_user_device_core_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(user_device_core_sptr self, unsigned int const device_id, unsigned int const packet_len, std::vector< unsigned char,std::allocator< unsigned char > > const & request_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_utb) -> user_device_core_sptr

        Return a shared_ptr to a new instance of howto::user_device_core.

        To avoid accidental use of raw pointers, howto::user_device_core's constructor is in a private implementation class. howto::user_device_core::make is the public interface for creating new instances.

        Params: (device_id, packet_len, request_utb, acknowledgement_btu, acknowledgement_utb, acknowledgement_end_btu, acknowledgement_end_utb)
        """
        return _howto_swig.user_device_core_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(user_device_core_sptr self) -> unsigned int"""
        return _howto_swig.user_device_core_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(user_device_core_sptr self, int which, int delay)
        declare_sample_delay(user_device_core_sptr self, unsigned int delay)
        """
        return _howto_swig.user_device_core_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(user_device_core_sptr self, int which) -> unsigned int"""
        return _howto_swig.user_device_core_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(user_device_core_sptr self) -> int"""
        return _howto_swig.user_device_core_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(user_device_core_sptr self) -> double"""
        return _howto_swig.user_device_core_sptr_relative_rate(self)

    def start(self):
        """start(user_device_core_sptr self) -> bool"""
        return _howto_swig.user_device_core_sptr_start(self)

    def stop(self):
        """stop(user_device_core_sptr self) -> bool"""
        return _howto_swig.user_device_core_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(user_device_core_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.user_device_core_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(user_device_core_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.user_device_core_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(user_device_core_sptr self) -> int"""
        return _howto_swig.user_device_core_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(user_device_core_sptr self, int m)"""
        return _howto_swig.user_device_core_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(user_device_core_sptr self)"""
        return _howto_swig.user_device_core_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(user_device_core_sptr self) -> bool"""
        return _howto_swig.user_device_core_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(user_device_core_sptr self, int m)"""
        return _howto_swig.user_device_core_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(user_device_core_sptr self) -> int"""
        return _howto_swig.user_device_core_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(user_device_core_sptr self, int i) -> long"""
        return _howto_swig.user_device_core_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(user_device_core_sptr self, long max_output_buffer)
        set_max_output_buffer(user_device_core_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.user_device_core_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(user_device_core_sptr self, int i) -> long"""
        return _howto_swig.user_device_core_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(user_device_core_sptr self, long min_output_buffer)
        set_min_output_buffer(user_device_core_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.user_device_core_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(user_device_core_sptr self) -> float"""
        return _howto_swig.user_device_core_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(user_device_core_sptr self) -> float"""
        return _howto_swig.user_device_core_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(user_device_core_sptr self) -> float"""
        return _howto_swig.user_device_core_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(user_device_core_sptr self) -> float"""
        return _howto_swig.user_device_core_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(user_device_core_sptr self) -> float"""
        return _howto_swig.user_device_core_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(user_device_core_sptr self) -> float"""
        return _howto_swig.user_device_core_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(user_device_core_sptr self, int which) -> float
        pc_input_buffers_full(user_device_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_core_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(user_device_core_sptr self, int which) -> float
        pc_input_buffers_full_avg(user_device_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_core_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(user_device_core_sptr self, int which) -> float
        pc_input_buffers_full_var(user_device_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_core_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(user_device_core_sptr self, int which) -> float
        pc_output_buffers_full(user_device_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_core_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(user_device_core_sptr self, int which) -> float
        pc_output_buffers_full_avg(user_device_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_core_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(user_device_core_sptr self, int which) -> float
        pc_output_buffers_full_var(user_device_core_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_core_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(user_device_core_sptr self) -> float"""
        return _howto_swig.user_device_core_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(user_device_core_sptr self) -> float"""
        return _howto_swig.user_device_core_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(user_device_core_sptr self) -> float"""
        return _howto_swig.user_device_core_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(user_device_core_sptr self) -> float"""
        return _howto_swig.user_device_core_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(user_device_core_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.user_device_core_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(user_device_core_sptr self)"""
        return _howto_swig.user_device_core_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(user_device_core_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.user_device_core_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(user_device_core_sptr self) -> int"""
        return _howto_swig.user_device_core_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(user_device_core_sptr self) -> int"""
        return _howto_swig.user_device_core_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(user_device_core_sptr self, int priority) -> int"""
        return _howto_swig.user_device_core_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(user_device_core_sptr self) -> std::string"""
        return _howto_swig.user_device_core_sptr_name(self)

    def symbol_name(self):
        """symbol_name(user_device_core_sptr self) -> std::string"""
        return _howto_swig.user_device_core_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(user_device_core_sptr self) -> io_signature_sptr"""
        return _howto_swig.user_device_core_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(user_device_core_sptr self) -> io_signature_sptr"""
        return _howto_swig.user_device_core_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(user_device_core_sptr self) -> long"""
        return _howto_swig.user_device_core_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(user_device_core_sptr self) -> basic_block_sptr"""
        return _howto_swig.user_device_core_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(user_device_core_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.user_device_core_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(user_device_core_sptr self) -> std::string"""
        return _howto_swig.user_device_core_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(user_device_core_sptr self, std::string name)"""
        return _howto_swig.user_device_core_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(user_device_core_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.user_device_core_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(user_device_core_sptr self) -> swig_int_ptr"""
        return _howto_swig.user_device_core_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(user_device_core_sptr self) -> swig_int_ptr"""
        return _howto_swig.user_device_core_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(user_device_core_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.user_device_core_sptr_message_subscribers(self, *args, **kwargs)

user_device_core_sptr_swigregister = _howto_swig.user_device_core_sptr_swigregister
user_device_core_sptr_swigregister(user_device_core_sptr)

user_device_core_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
user_device_core = user_device_core.make;

class user_device_debug(object):
    """<+description of block+>"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< unsigned char,std::allocator< unsigned char > > const & data, unsigned int const device_id, 
            unsigned int const packet_len, std::vector< unsigned char,std::allocator< unsigned char > > const & request_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_utb) -> user_device_debug_sptr

        Return a shared_ptr to a new instance of howto::user_device_debug.

        To avoid accidental use of raw pointers, howto::user_device_debug's constructor is in a private implementation class. howto::user_device_debug::make is the public interface for creating new instances.

        Params: (data, device_id, packet_len, request_utb, acknowledgement_btu, acknowledgement_utb, acknowledgement_end_btu, acknowledgement_end_utb)
        """
        return _howto_swig.user_device_debug_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_user_device_debug
    __del__ = lambda self : None;
user_device_debug_swigregister = _howto_swig.user_device_debug_swigregister
user_device_debug_swigregister(user_device_debug)

def user_device_debug_make(*args, **kwargs):
  """
    user_device_debug_make(std::vector< unsigned char,std::allocator< unsigned char > > const & data, unsigned int const device_id, 
        unsigned int const packet_len, std::vector< unsigned char,std::allocator< unsigned char > > const & request_utb, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_btu, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_utb, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_btu, 
        std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_utb) -> user_device_debug_sptr

    Return a shared_ptr to a new instance of howto::user_device_debug.

    To avoid accidental use of raw pointers, howto::user_device_debug's constructor is in a private implementation class. howto::user_device_debug::make is the public interface for creating new instances.

    Params: (data, device_id, packet_len, request_utb, acknowledgement_btu, acknowledgement_utb, acknowledgement_end_btu, acknowledgement_end_utb)
    """
  return _howto_swig.user_device_debug_make(*args, **kwargs)

class user_device_debug_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::user_device_debug)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::user_device_debug)> self) -> user_device_debug_sptr
        __init__(boost::shared_ptr<(gr::howto::user_device_debug)> self, user_device_debug p) -> user_device_debug_sptr
        """
        this = _howto_swig.new_user_device_debug_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(user_device_debug_sptr self) -> user_device_debug"""
        return _howto_swig.user_device_debug_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_user_device_debug_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(user_device_debug_sptr self, std::vector< unsigned char,std::allocator< unsigned char > > const & data, unsigned int const device_id, 
            unsigned int const packet_len, std::vector< unsigned char,std::allocator< unsigned char > > const & request_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_utb, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_btu, 
            std::vector< unsigned char,std::allocator< unsigned char > > const & acknowledgement_end_utb) -> user_device_debug_sptr

        Return a shared_ptr to a new instance of howto::user_device_debug.

        To avoid accidental use of raw pointers, howto::user_device_debug's constructor is in a private implementation class. howto::user_device_debug::make is the public interface for creating new instances.

        Params: (data, device_id, packet_len, request_utb, acknowledgement_btu, acknowledgement_utb, acknowledgement_end_btu, acknowledgement_end_utb)
        """
        return _howto_swig.user_device_debug_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(user_device_debug_sptr self) -> unsigned int"""
        return _howto_swig.user_device_debug_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(user_device_debug_sptr self, int which, int delay)
        declare_sample_delay(user_device_debug_sptr self, unsigned int delay)
        """
        return _howto_swig.user_device_debug_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(user_device_debug_sptr self, int which) -> unsigned int"""
        return _howto_swig.user_device_debug_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(user_device_debug_sptr self) -> int"""
        return _howto_swig.user_device_debug_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(user_device_debug_sptr self) -> double"""
        return _howto_swig.user_device_debug_sptr_relative_rate(self)

    def start(self):
        """start(user_device_debug_sptr self) -> bool"""
        return _howto_swig.user_device_debug_sptr_start(self)

    def stop(self):
        """stop(user_device_debug_sptr self) -> bool"""
        return _howto_swig.user_device_debug_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(user_device_debug_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.user_device_debug_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(user_device_debug_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.user_device_debug_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(user_device_debug_sptr self) -> int"""
        return _howto_swig.user_device_debug_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(user_device_debug_sptr self, int m)"""
        return _howto_swig.user_device_debug_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(user_device_debug_sptr self)"""
        return _howto_swig.user_device_debug_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(user_device_debug_sptr self) -> bool"""
        return _howto_swig.user_device_debug_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(user_device_debug_sptr self, int m)"""
        return _howto_swig.user_device_debug_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(user_device_debug_sptr self) -> int"""
        return _howto_swig.user_device_debug_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(user_device_debug_sptr self, int i) -> long"""
        return _howto_swig.user_device_debug_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(user_device_debug_sptr self, long max_output_buffer)
        set_max_output_buffer(user_device_debug_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.user_device_debug_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(user_device_debug_sptr self, int i) -> long"""
        return _howto_swig.user_device_debug_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(user_device_debug_sptr self, long min_output_buffer)
        set_min_output_buffer(user_device_debug_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.user_device_debug_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(user_device_debug_sptr self) -> float"""
        return _howto_swig.user_device_debug_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(user_device_debug_sptr self) -> float"""
        return _howto_swig.user_device_debug_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(user_device_debug_sptr self) -> float"""
        return _howto_swig.user_device_debug_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(user_device_debug_sptr self) -> float"""
        return _howto_swig.user_device_debug_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(user_device_debug_sptr self) -> float"""
        return _howto_swig.user_device_debug_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(user_device_debug_sptr self) -> float"""
        return _howto_swig.user_device_debug_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(user_device_debug_sptr self, int which) -> float
        pc_input_buffers_full(user_device_debug_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_debug_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(user_device_debug_sptr self, int which) -> float
        pc_input_buffers_full_avg(user_device_debug_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_debug_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(user_device_debug_sptr self, int which) -> float
        pc_input_buffers_full_var(user_device_debug_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_debug_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(user_device_debug_sptr self, int which) -> float
        pc_output_buffers_full(user_device_debug_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_debug_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(user_device_debug_sptr self, int which) -> float
        pc_output_buffers_full_avg(user_device_debug_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_debug_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(user_device_debug_sptr self, int which) -> float
        pc_output_buffers_full_var(user_device_debug_sptr self) -> pmt_vector_float
        """
        return _howto_swig.user_device_debug_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(user_device_debug_sptr self) -> float"""
        return _howto_swig.user_device_debug_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(user_device_debug_sptr self) -> float"""
        return _howto_swig.user_device_debug_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(user_device_debug_sptr self) -> float"""
        return _howto_swig.user_device_debug_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(user_device_debug_sptr self) -> float"""
        return _howto_swig.user_device_debug_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(user_device_debug_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.user_device_debug_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(user_device_debug_sptr self)"""
        return _howto_swig.user_device_debug_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(user_device_debug_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.user_device_debug_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(user_device_debug_sptr self) -> int"""
        return _howto_swig.user_device_debug_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(user_device_debug_sptr self) -> int"""
        return _howto_swig.user_device_debug_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(user_device_debug_sptr self, int priority) -> int"""
        return _howto_swig.user_device_debug_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(user_device_debug_sptr self) -> std::string"""
        return _howto_swig.user_device_debug_sptr_name(self)

    def symbol_name(self):
        """symbol_name(user_device_debug_sptr self) -> std::string"""
        return _howto_swig.user_device_debug_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(user_device_debug_sptr self) -> io_signature_sptr"""
        return _howto_swig.user_device_debug_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(user_device_debug_sptr self) -> io_signature_sptr"""
        return _howto_swig.user_device_debug_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(user_device_debug_sptr self) -> long"""
        return _howto_swig.user_device_debug_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(user_device_debug_sptr self) -> basic_block_sptr"""
        return _howto_swig.user_device_debug_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(user_device_debug_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.user_device_debug_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(user_device_debug_sptr self) -> std::string"""
        return _howto_swig.user_device_debug_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(user_device_debug_sptr self, std::string name)"""
        return _howto_swig.user_device_debug_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(user_device_debug_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.user_device_debug_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(user_device_debug_sptr self) -> swig_int_ptr"""
        return _howto_swig.user_device_debug_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(user_device_debug_sptr self) -> swig_int_ptr"""
        return _howto_swig.user_device_debug_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(user_device_debug_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.user_device_debug_sptr_message_subscribers(self, *args, **kwargs)

user_device_debug_sptr_swigregister = _howto_swig.user_device_debug_sptr_swigregister
user_device_debug_sptr_swigregister(user_device_debug_sptr)

user_device_debug_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
user_device_debug = user_device_debug.make;

class ofdm_outer_headerparser_bb(object):
    """<+description of block+>"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers) -> ofdm_outer_headerparser_bb_sptr

        Return a shared_ptr to a new instance of howto::ofdm_outer_headerparser_bb.

        To avoid accidental use of raw pointers, howto::ofdm_outer_headerparser_bb's constructor is in a private implementation class. howto::ofdm_outer_headerparser_bb::make is the public interface for creating new instances.

        Params: (fft_len, occupied_carriers)
        """
        return _howto_swig.ofdm_outer_headerparser_bb_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _howto_swig.delete_ofdm_outer_headerparser_bb
    __del__ = lambda self : None;
ofdm_outer_headerparser_bb_swigregister = _howto_swig.ofdm_outer_headerparser_bb_swigregister
ofdm_outer_headerparser_bb_swigregister(ofdm_outer_headerparser_bb)

def ofdm_outer_headerparser_bb_make(*args, **kwargs):
  """
    ofdm_outer_headerparser_bb_make(int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers) -> ofdm_outer_headerparser_bb_sptr

    Return a shared_ptr to a new instance of howto::ofdm_outer_headerparser_bb.

    To avoid accidental use of raw pointers, howto::ofdm_outer_headerparser_bb's constructor is in a private implementation class. howto::ofdm_outer_headerparser_bb::make is the public interface for creating new instances.

    Params: (fft_len, occupied_carriers)
    """
  return _howto_swig.ofdm_outer_headerparser_bb_make(*args, **kwargs)

class ofdm_outer_headerparser_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::howto::ofdm_outer_headerparser_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::howto::ofdm_outer_headerparser_bb)> self) -> ofdm_outer_headerparser_bb_sptr
        __init__(boost::shared_ptr<(gr::howto::ofdm_outer_headerparser_bb)> self, ofdm_outer_headerparser_bb p) -> ofdm_outer_headerparser_bb_sptr
        """
        this = _howto_swig.new_ofdm_outer_headerparser_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_outer_headerparser_bb_sptr self) -> ofdm_outer_headerparser_bb"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr___deref__(self)

    __swig_destroy__ = _howto_swig.delete_ofdm_outer_headerparser_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_outer_headerparser_bb_sptr self, int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers) -> ofdm_outer_headerparser_bb_sptr

        Return a shared_ptr to a new instance of howto::ofdm_outer_headerparser_bb.

        To avoid accidental use of raw pointers, howto::ofdm_outer_headerparser_bb's constructor is in a private implementation class. howto::ofdm_outer_headerparser_bb::make is the public interface for creating new instances.

        Params: (fft_len, occupied_carriers)
        """
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_outer_headerparser_bb_sptr self) -> unsigned int"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_outer_headerparser_bb_sptr self, int which, int delay)
        declare_sample_delay(ofdm_outer_headerparser_bb_sptr self, unsigned int delay)
        """
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_outer_headerparser_bb_sptr self, int which) -> unsigned int"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_outer_headerparser_bb_sptr self) -> int"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_outer_headerparser_bb_sptr self) -> double"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_outer_headerparser_bb_sptr self) -> bool"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_start(self)

    def stop(self):
        """stop(ofdm_outer_headerparser_bb_sptr self) -> bool"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_outer_headerparser_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_outer_headerparser_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_outer_headerparser_bb_sptr self) -> int"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_outer_headerparser_bb_sptr self, int m)"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_outer_headerparser_bb_sptr self)"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_outer_headerparser_bb_sptr self) -> bool"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_outer_headerparser_bb_sptr self, int m)"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_outer_headerparser_bb_sptr self) -> int"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_outer_headerparser_bb_sptr self, int i) -> long"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_outer_headerparser_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_outer_headerparser_bb_sptr self, int port, long max_output_buffer)
        """
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_outer_headerparser_bb_sptr self, int i) -> long"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_outer_headerparser_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_outer_headerparser_bb_sptr self, int port, long min_output_buffer)
        """
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_outer_headerparser_bb_sptr self) -> float"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_outer_headerparser_bb_sptr self) -> float"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_outer_headerparser_bb_sptr self) -> float"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_outer_headerparser_bb_sptr self) -> float"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_outer_headerparser_bb_sptr self) -> float"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_outer_headerparser_bb_sptr self) -> float"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_outer_headerparser_bb_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_outer_headerparser_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_outer_headerparser_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_outer_headerparser_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_outer_headerparser_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_outer_headerparser_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_outer_headerparser_bb_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_outer_headerparser_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_outer_headerparser_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_outer_headerparser_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_outer_headerparser_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_outer_headerparser_bb_sptr self) -> pmt_vector_float
        """
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_outer_headerparser_bb_sptr self) -> float"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_outer_headerparser_bb_sptr self) -> float"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_outer_headerparser_bb_sptr self) -> float"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_outer_headerparser_bb_sptr self) -> float"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_outer_headerparser_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_outer_headerparser_bb_sptr self)"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_outer_headerparser_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_outer_headerparser_bb_sptr self) -> int"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_outer_headerparser_bb_sptr self) -> int"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_outer_headerparser_bb_sptr self, int priority) -> int"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_outer_headerparser_bb_sptr self) -> std::string"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_outer_headerparser_bb_sptr self) -> std::string"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_outer_headerparser_bb_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_outer_headerparser_bb_sptr self) -> io_signature_sptr"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_outer_headerparser_bb_sptr self) -> long"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_outer_headerparser_bb_sptr self) -> basic_block_sptr"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_outer_headerparser_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_outer_headerparser_bb_sptr self) -> std::string"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_outer_headerparser_bb_sptr self, std::string name)"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_outer_headerparser_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_outer_headerparser_bb_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_outer_headerparser_bb_sptr self) -> swig_int_ptr"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_outer_headerparser_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _howto_swig.ofdm_outer_headerparser_bb_sptr_message_subscribers(self, *args, **kwargs)

ofdm_outer_headerparser_bb_sptr_swigregister = _howto_swig.ofdm_outer_headerparser_bb_sptr_swigregister
ofdm_outer_headerparser_bb_sptr_swigregister(ofdm_outer_headerparser_bb_sptr)

ofdm_outer_headerparser_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_outer_headerparser_bb = ofdm_outer_headerparser_bb.make;



